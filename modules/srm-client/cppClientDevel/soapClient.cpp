/* soapClient.cpp
   Generated by gSOAP 2.2.3b from managerv1.h
   Copyright (C) 2001-2003 Genivia inc.
   All Rights Reserved.
*/
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapClient.cpp ver 2.2.3b 2003-04-14 22:12:44 GMT")


SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__ping(struct soap *soap, const char *URL, const char *action, tns__pingResponse *out)
{
	struct tns__ping soap_tmp_tns__ping;
	if (!action)
		action = "ping";
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__ping(soap, &soap_tmp_tns__ping);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__ping(soap, &soap_tmp_tns__ping, "tns:ping", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__ping(soap, &soap_tmp_tns__ping, "tns:ping", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:pingResponse", "tns:pingResponse");
	else
		soap_get_tns__pingResponse(soap, out, "tns:pingResponse", "tns:pingResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__getEstPutTime(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, ArrayOfstring *arg1, ArrayOflong *arg2, ArrayOfboolean *arg3, ArrayOfstring *arg4, tns__getEstPutTimeResponse *out)
{
	struct tns__getEstPutTime soap_tmp_tns__getEstPutTime;
	if (!action)
		action = "getEstPutTime";
	soap_tmp_tns__getEstPutTime.arg0=arg0;
	soap_tmp_tns__getEstPutTime.arg1=arg1;
	soap_tmp_tns__getEstPutTime.arg2=arg2;
	soap_tmp_tns__getEstPutTime.arg3=arg3;
	soap_tmp_tns__getEstPutTime.arg4=arg4;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__getEstPutTime(soap, &soap_tmp_tns__getEstPutTime);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__getEstPutTime(soap, &soap_tmp_tns__getEstPutTime, "tns:getEstPutTime", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__getEstPutTime(soap, &soap_tmp_tns__getEstPutTime, "tns:getEstPutTime", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:getEstPutTimeResponse", "tns:getEstPutTimeResponse");
	else
		soap_get_tns__getEstPutTimeResponse(soap, out, "tns:getEstPutTimeResponse", "tns:getEstPutTimeResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__put(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, ArrayOfstring *arg1, ArrayOflong *arg2, ArrayOfboolean *arg3, ArrayOfstring *arg4, tns__putResponse *out)
{
	struct tns__put soap_tmp_tns__put;
	if (!action)
		action = "put";
	soap_tmp_tns__put.arg0=arg0;
	soap_tmp_tns__put.arg1=arg1;
	soap_tmp_tns__put.arg2=arg2;
	soap_tmp_tns__put.arg3=arg3;
	soap_tmp_tns__put.arg4=arg4;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__put(soap, &soap_tmp_tns__put);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__put(soap, &soap_tmp_tns__put, "tns:put", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__put(soap, &soap_tmp_tns__put, "tns:put", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:putResponse", "tns:putResponse");
	else
		soap_get_tns__putResponse(soap, out, "tns:putResponse", "tns:putResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__getRequestStatus(struct soap *soap, const char *URL, const char *action, int arg0, tns__getRequestStatusResponse *out)
{
	struct tns__getRequestStatus soap_tmp_tns__getRequestStatus;
	if (!action)
		action = "getRequestStatus";
	soap_tmp_tns__getRequestStatus.arg0=arg0;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__getRequestStatus(soap, &soap_tmp_tns__getRequestStatus);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__getRequestStatus(soap, &soap_tmp_tns__getRequestStatus, "tns:getRequestStatus", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__getRequestStatus(soap, &soap_tmp_tns__getRequestStatus, "tns:getRequestStatus", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:getRequestStatusResponse", "tns:getRequestStatusResponse");
	else
		soap_get_tns__getRequestStatusResponse(soap, out, "tns:getRequestStatusResponse", "tns:getRequestStatusResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__copy(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, ArrayOfstring *arg1, ArrayOfboolean *arg2, tns__copyResponse *out)
{
	struct tns__copy soap_tmp_tns__copy;
	if (!action)
		action = "copy";
	soap_tmp_tns__copy.arg0=arg0;
	soap_tmp_tns__copy.arg1=arg1;
	soap_tmp_tns__copy.arg2=arg2;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__copy(soap, &soap_tmp_tns__copy);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__copy(soap, &soap_tmp_tns__copy, "tns:copy", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__copy(soap, &soap_tmp_tns__copy, "tns:copy", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:copyResponse", "tns:copyResponse");
	else
		soap_get_tns__copyResponse(soap, out, "tns:copyResponse", "tns:copyResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__getProtocols(struct soap *soap, const char *URL, const char *action, tns__getProtocolsResponse *out)
{
	struct tns__getProtocols soap_tmp_tns__getProtocols;
	if (!action)
		action = "getProtocols";
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__getProtocols(soap, &soap_tmp_tns__getProtocols);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__getProtocols(soap, &soap_tmp_tns__getProtocols, "tns:getProtocols", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__getProtocols(soap, &soap_tmp_tns__getProtocols, "tns:getProtocols", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:getProtocolsResponse", "tns:getProtocolsResponse");
	else
		soap_get_tns__getProtocolsResponse(soap, out, "tns:getProtocolsResponse", "tns:getProtocolsResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__getEstGetTime(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, ArrayOfstring *arg1, tns__getEstGetTimeResponse *out)
{
	struct tns__getEstGetTime soap_tmp_tns__getEstGetTime;
	if (!action)
		action = "getEstGetTime";
	soap_tmp_tns__getEstGetTime.arg0=arg0;
	soap_tmp_tns__getEstGetTime.arg1=arg1;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__getEstGetTime(soap, &soap_tmp_tns__getEstGetTime);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__getEstGetTime(soap, &soap_tmp_tns__getEstGetTime, "tns:getEstGetTime", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__getEstGetTime(soap, &soap_tmp_tns__getEstGetTime, "tns:getEstGetTime", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:getEstGetTimeResponse", "tns:getEstGetTimeResponse");
	else
		soap_get_tns__getEstGetTimeResponse(soap, out, "tns:getEstGetTimeResponse", "tns:getEstGetTimeResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__advisoryDelete(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, tns__advisoryDeleteResponse *out)
{
	struct tns__advisoryDelete soap_tmp_tns__advisoryDelete;
	if (!action)
		action = "advisoryDelete";
	soap_tmp_tns__advisoryDelete.arg0=arg0;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__advisoryDelete(soap, &soap_tmp_tns__advisoryDelete);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__advisoryDelete(soap, &soap_tmp_tns__advisoryDelete, "tns:advisoryDelete", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__advisoryDelete(soap, &soap_tmp_tns__advisoryDelete, "tns:advisoryDelete", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:advisoryDeleteResponse", "tns:advisoryDeleteResponse");
	else
		soap_get_tns__advisoryDeleteResponse(soap, out, "tns:advisoryDeleteResponse", "tns:advisoryDeleteResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__pin(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, tns__pinResponse *out)
{
	struct tns__pin soap_tmp_tns__pin;
	if (!action)
		action = "pin";
	soap_tmp_tns__pin.arg0=arg0;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__pin(soap, &soap_tmp_tns__pin);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__pin(soap, &soap_tmp_tns__pin, "tns:pin", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__pin(soap, &soap_tmp_tns__pin, "tns:pin", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:pinResponse", "tns:pinResponse");
	else
		soap_get_tns__pinResponse(soap, out, "tns:pinResponse", "tns:pinResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__unPin(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, int arg1, tns__unPinResponse *out)
{
	struct tns__unPin soap_tmp_tns__unPin;
	if (!action)
		action = "unPin";
	soap_tmp_tns__unPin.arg0=arg0;
	soap_tmp_tns__unPin.arg1=arg1;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__unPin(soap, &soap_tmp_tns__unPin);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__unPin(soap, &soap_tmp_tns__unPin, "tns:unPin", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__unPin(soap, &soap_tmp_tns__unPin, "tns:unPin", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:unPinResponse", "tns:unPinResponse");
	else
		soap_get_tns__unPinResponse(soap, out, "tns:unPinResponse", "tns:unPinResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__setFileStatus(struct soap *soap, const char *URL, const char *action, int arg0, int arg1, char *arg2, tns__setFileStatusResponse *out)
{
	struct tns__setFileStatus soap_tmp_tns__setFileStatus;
	if (!action)
		action = "setFileStatus";
	soap_tmp_tns__setFileStatus.arg0=arg0;
	soap_tmp_tns__setFileStatus.arg1=arg1;
	soap_tmp_tns__setFileStatus.arg2=arg2;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__setFileStatus(soap, &soap_tmp_tns__setFileStatus);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__setFileStatus(soap, &soap_tmp_tns__setFileStatus, "tns:setFileStatus", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__setFileStatus(soap, &soap_tmp_tns__setFileStatus, "tns:setFileStatus", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:setFileStatusResponse", "tns:setFileStatusResponse");
	else
		soap_get_tns__setFileStatusResponse(soap, out, "tns:setFileStatusResponse", "tns:setFileStatusResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__mkPermanent(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, tns__mkPermanentResponse *out)
{
	struct tns__mkPermanent soap_tmp_tns__mkPermanent;
	if (!action)
		action = "mkPermanent";
	soap_tmp_tns__mkPermanent.arg0=arg0;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__mkPermanent(soap, &soap_tmp_tns__mkPermanent);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__mkPermanent(soap, &soap_tmp_tns__mkPermanent, "tns:mkPermanent", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__mkPermanent(soap, &soap_tmp_tns__mkPermanent, "tns:mkPermanent", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:mkPermanentResponse", "tns:mkPermanentResponse");
	else
		soap_get_tns__mkPermanentResponse(soap, out, "tns:mkPermanentResponse", "tns:mkPermanentResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__get(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, ArrayOfstring *arg1, tns__getResponse *out)
{
	struct tns__get soap_tmp_tns__get;
	if (!action)
		action = "get";
	soap_tmp_tns__get.arg0=arg0;
	soap_tmp_tns__get.arg1=arg1;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__get(soap, &soap_tmp_tns__get);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__get(soap, &soap_tmp_tns__get, "tns:get", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__get(soap, &soap_tmp_tns__get, "tns:get", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:getResponse", "tns:getResponse");
	else
		soap_get_tns__getResponse(soap, out, "tns:getResponse", "tns:getResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_call_tns__getFileMetaData(struct soap *soap, const char *URL, const char *action, ArrayOfstring *arg0, tns__getFileMetaDataResponse *out)
{
	struct tns__getFileMetaData soap_tmp_tns__getFileMetaData;
	if (!action)
		action = "getFileMetaData";
	soap_tmp_tns__getFileMetaData.arg0=arg0;
	soap_begin(soap);
	soap_serializeheader(soap);
	soap_serialize_tns__getFileMetaData(soap, &soap_tmp_tns__getFileMetaData);
	soap_begin_count(soap);
	if (soap->mode & SOAP_IO_LENGTH)
	{	soap_envelope_begin_out(soap);
		soap_putheader(soap);
		soap_body_begin_out(soap);
		soap_put_tns__getFileMetaData(soap, &soap_tmp_tns__getFileMetaData, "tns:getFileMetaData", "");
		soap_body_end_out(soap);
		soap_envelope_end_out(soap);
	}
	if (soap_connect(soap, URL, action)
	 || soap_envelope_begin_out(soap)
	 || soap_putheader(soap)
	 || soap_body_begin_out(soap)
	 || soap_put_tns__getFileMetaData(soap, &soap_tmp_tns__getFileMetaData, "tns:getFileMetaData", "")
	 || soap_body_end_out(soap)
	 || soap_envelope_end_out(soap)
	 || soap_putattachments(soap)
	 || soap_end_send(soap))
		return soap->error;
	if (out)
		out->soap_default(soap);
	if (soap_begin_recv(soap)
	 || soap_envelope_begin_in(soap)
	 || soap_recv_header(soap)
	 || soap_body_begin_in(soap))
		return soap->error;
	if (out)
		out->soap_get(soap, "tns:getFileMetaDataResponse", "tns:getFileMetaDataResponse");
	else
		soap_get_tns__getFileMetaDataResponse(soap, out, "tns:getFileMetaDataResponse", "tns:getFileMetaDataResponse");
	if (soap->error)
	{	if (soap->error == SOAP_TAG_MISMATCH && soap->level == 2)
			soap_recv_fault(soap);
		return soap->error;
	}
	if (soap_body_end_in(soap)
	 || soap_envelope_end_in(soap)
	 || soap_getattachments(soap)
	 || soap_end_recv(soap))
		return soap->error;
	soap_closesock(soap);
	return SOAP_OK;
}

/* end of soapClient.cpp */
