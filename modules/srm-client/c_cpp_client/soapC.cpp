/* soapC.cpp
   Generated by gSOAP 2.2.3b from managerv1.h
   Copyright (C) 2001-2003 Genivia inc.
   All Rights Reserved.
*/
#include "soapH.h"

SOAP_SOURCE_STAMP("@(#) soapC.cpp ver 2.2.3b 2003-04-14 22:12:44 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serializeheader(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->is_in_header = 1;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->is_in_header = 0;
	}
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getheader(struct soap *soap)
{
	soap->is_in_header = 1;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->is_in_header = 0;
	return soap->header == NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serializefault(struct soap *soap)
{
	soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putfault(struct soap *soap)
{
	return soap_out_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", 0, soap->fault, NULL);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_in_SOAP_ENV__Fault(soap, "SOAP-ENV:Fault", NULL, NULL)) == NULL;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC1 const char ** SOAP_FMAC2 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Detail;
	return (const char**)&soap->fault->detail;
}

#endif

SOAP_FMAC1 int SOAP_FMAC2 soap_getindependent(struct soap *soap)
{
	for (;;)
	{	if (soap_peek_element(soap))
			break;
		switch (soap_lookup_type(soap, soap->id))
		{
		case SOAP_TYPE_byte:
			soap_in_byte(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_tns__Integer:
			soap_in_tns__Integer(soap, NULL, NULL, "tns:Integer");
			break;
		case SOAP_TYPE_xsd__int:
			soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
			break;
		case SOAP_TYPE_int:
			soap_in_int(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_tns__Long:
			soap_in_tns__Long(soap, NULL, NULL, "tns:Long");
			break;
		case SOAP_TYPE_xsd__long:
			soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
			break;
		case SOAP_TYPE_LONG64:
			soap_in_LONG64(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_tns__Boolean:
			soap_in_tns__Boolean(soap, NULL, NULL, "tns:Boolean");
			break;
		case SOAP_TYPE_xsd__boolean:
			soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
			break;
		case SOAP_TYPE_bool:
			soap_in_bool(soap, NULL, NULL, "");
			break;
		case SOAP_TYPE_ArrayOfboolean:
			soap_in_ArrayOfboolean(soap, NULL, NULL, "xsd:boolean");
			break;
		case SOAP_TYPE_tns__unPinResponse:
			soap_in_tns__unPinResponse(soap, NULL, NULL, "tns:unPinResponse");
			break;
		case SOAP_TYPE_tns__setFileStatusResponse:
			soap_in_tns__setFileStatusResponse(soap, NULL, NULL, "tns:setFileStatusResponse");
			break;
		case SOAP_TYPE_tns__getProtocolsResponse:
			soap_in_tns__getProtocolsResponse(soap, NULL, NULL, "tns:getProtocolsResponse");
			break;
		case SOAP_TYPE_tns__getRequestStatusResponse:
			soap_in_tns__getRequestStatusResponse(soap, NULL, NULL, "tns:getRequestStatusResponse");
			break;
		case SOAP_TYPE_tns__getFileMetaDataResponse:
			soap_in_tns__getFileMetaDataResponse(soap, NULL, NULL, "tns:getFileMetaDataResponse");
			break;
		case SOAP_TYPE_tns__pingResponse:
			soap_in_tns__pingResponse(soap, NULL, NULL, "tns:pingResponse");
			break;
		case SOAP_TYPE_tns__pinResponse:
			soap_in_tns__pinResponse(soap, NULL, NULL, "tns:pinResponse");
			break;
		case SOAP_TYPE_tns__getEstPutTimeResponse:
			soap_in_tns__getEstPutTimeResponse(soap, NULL, NULL, "tns:getEstPutTimeResponse");
			break;
		case SOAP_TYPE_tns__getEstGetTimeResponse:
			soap_in_tns__getEstGetTimeResponse(soap, NULL, NULL, "tns:getEstGetTimeResponse");
			break;
		case SOAP_TYPE_tns__copyResponse:
			soap_in_tns__copyResponse(soap, NULL, NULL, "tns:copyResponse");
			break;
		case SOAP_TYPE_tns__mkPermanentResponse:
			soap_in_tns__mkPermanentResponse(soap, NULL, NULL, "tns:mkPermanentResponse");
			break;
		case SOAP_TYPE_ns11__RequestFileStatus:
			soap_in_ns11__RequestFileStatus(soap, NULL, NULL, "ns11:RequestFileStatus");
			break;
		case SOAP_TYPE_tns__putResponse:
			soap_in_tns__putResponse(soap, NULL, NULL, "tns:putResponse");
			break;
		case SOAP_TYPE_ArrayOflong:
			soap_in_ArrayOflong(soap, NULL, NULL, "xsd:long");
			break;
		case SOAP_TYPE_ArrayOfstring:
			soap_in_ArrayOfstring(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_ns11__FileMetaData:
			soap_in_ns11__FileMetaData(soap, NULL, NULL, "ns11:FileMetaData");
			break;
		case SOAP_TYPE_ArrayOfFileMetaData:
			soap_in_ArrayOfFileMetaData(soap, NULL, NULL, "ns11:FileMetaData");
			break;
		case SOAP_TYPE_ArrayOfRequestFileStatus:
			soap_in_ArrayOfRequestFileStatus(soap, NULL, NULL, "ns11:RequestFileStatus");
			break;
		case SOAP_TYPE_tns__advisoryDeleteResponse:
			soap_in_tns__advisoryDeleteResponse(soap, NULL, NULL, "tns:advisoryDeleteResponse");
			break;
		case SOAP_TYPE_ns11__RequestStatus:
			soap_in_ns11__RequestStatus(soap, NULL, NULL, "ns11:RequestStatus");
			break;
		case SOAP_TYPE_tns__getResponse:
			soap_in_tns__getResponse(soap, NULL, NULL, "tns:getResponse");
			break;
		case SOAP_TYPE_tns__getFileMetaData:
			soap_in_tns__getFileMetaData(soap, NULL, NULL, "tns:getFileMetaData");
			break;
		case SOAP_TYPE_tns__get:
			soap_in_tns__get(soap, NULL, NULL, "tns:get");
			break;
		case SOAP_TYPE_tns__mkPermanent:
			soap_in_tns__mkPermanent(soap, NULL, NULL, "tns:mkPermanent");
			break;
		case SOAP_TYPE_tns__setFileStatus:
			soap_in_tns__setFileStatus(soap, NULL, NULL, "tns:setFileStatus");
			break;
		case SOAP_TYPE_tns__unPin:
			soap_in_tns__unPin(soap, NULL, NULL, "tns:unPin");
			break;
		case SOAP_TYPE_tns__pin:
			soap_in_tns__pin(soap, NULL, NULL, "tns:pin");
			break;
		case SOAP_TYPE_tns__advisoryDelete:
			soap_in_tns__advisoryDelete(soap, NULL, NULL, "tns:advisoryDelete");
			break;
		case SOAP_TYPE_tns__getEstGetTime:
			soap_in_tns__getEstGetTime(soap, NULL, NULL, "tns:getEstGetTime");
			break;
		case SOAP_TYPE_tns__getProtocols:
			soap_in_tns__getProtocols(soap, NULL, NULL, "tns:getProtocols");
			break;
		case SOAP_TYPE_tns__copy:
			soap_in_tns__copy(soap, NULL, NULL, "tns:copy");
			break;
		case SOAP_TYPE_tns__getRequestStatus:
			soap_in_tns__getRequestStatus(soap, NULL, NULL, "tns:getRequestStatus");
			break;
		case SOAP_TYPE_tns__put:
			soap_in_tns__put(soap, NULL, NULL, "tns:put");
			break;
		case SOAP_TYPE_tns__getEstPutTime:
			soap_in_tns__getEstPutTime(soap, NULL, NULL, "tns:getEstPutTime");
			break;
		case SOAP_TYPE_tns__ping:
			soap_in_tns__ping(soap, NULL, NULL, "tns:ping");
			break;
		case SOAP_TYPE_PointerTotns__getFileMetaDataResponse:
			soap_in_PointerTotns__getFileMetaDataResponse(soap, NULL, NULL, "tns:getFileMetaDataResponse");
			break;
		case SOAP_TYPE_PointerTotns__getResponse:
			soap_in_PointerTotns__getResponse(soap, NULL, NULL, "tns:getResponse");
			break;
		case SOAP_TYPE_PointerTotns__mkPermanentResponse:
			soap_in_PointerTotns__mkPermanentResponse(soap, NULL, NULL, "tns:mkPermanentResponse");
			break;
		case SOAP_TYPE_PointerTotns__setFileStatusResponse:
			soap_in_PointerTotns__setFileStatusResponse(soap, NULL, NULL, "tns:setFileStatusResponse");
			break;
		case SOAP_TYPE_PointerTotns__unPinResponse:
			soap_in_PointerTotns__unPinResponse(soap, NULL, NULL, "tns:unPinResponse");
			break;
		case SOAP_TYPE_PointerTotns__pinResponse:
			soap_in_PointerTotns__pinResponse(soap, NULL, NULL, "tns:pinResponse");
			break;
		case SOAP_TYPE_PointerTotns__advisoryDeleteResponse:
			soap_in_PointerTotns__advisoryDeleteResponse(soap, NULL, NULL, "tns:advisoryDeleteResponse");
			break;
		case SOAP_TYPE_PointerTotns__getEstGetTimeResponse:
			soap_in_PointerTotns__getEstGetTimeResponse(soap, NULL, NULL, "tns:getEstGetTimeResponse");
			break;
		case SOAP_TYPE_PointerTotns__getProtocolsResponse:
			soap_in_PointerTotns__getProtocolsResponse(soap, NULL, NULL, "tns:getProtocolsResponse");
			break;
		case SOAP_TYPE_PointerTotns__copyResponse:
			soap_in_PointerTotns__copyResponse(soap, NULL, NULL, "tns:copyResponse");
			break;
		case SOAP_TYPE_PointerTotns__getRequestStatusResponse:
			soap_in_PointerTotns__getRequestStatusResponse(soap, NULL, NULL, "tns:getRequestStatusResponse");
			break;
		case SOAP_TYPE_PointerTotns__putResponse:
			soap_in_PointerTotns__putResponse(soap, NULL, NULL, "tns:putResponse");
			break;
		case SOAP_TYPE_PointerTotns__getEstPutTimeResponse:
			soap_in_PointerTotns__getEstPutTimeResponse(soap, NULL, NULL, "tns:getEstPutTimeResponse");
			break;
		case SOAP_TYPE_PointerToArrayOfboolean:
			soap_in_PointerToArrayOfboolean(soap, NULL, NULL, "xsd:boolean");
			break;
		case SOAP_TYPE_PointerToArrayOflong:
			soap_in_PointerToArrayOflong(soap, NULL, NULL, "xsd:long");
			break;
		case SOAP_TYPE_PointerTotns__pingResponse:
			soap_in_PointerTotns__pingResponse(soap, NULL, NULL, "tns:pingResponse");
			break;
		case SOAP_TYPE_PointerToxsd__boolean:
			soap_in_PointerToxsd__boolean(soap, NULL, NULL, "xsd:boolean");
			break;
		case SOAP_TYPE_PointerToArrayOfstring:
			soap_in_PointerToArrayOfstring(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_PointerToArrayOfFileMetaData:
			soap_in_PointerToArrayOfFileMetaData(soap, NULL, NULL, "ns11:FileMetaData");
			break;
		case SOAP_TYPE_PointerTons11__RequestFileStatus:
			soap_in_PointerTons11__RequestFileStatus(soap, NULL, NULL, "ns11:RequestFileStatus");
			break;
		case SOAP_TYPE_PointerToxsd__long:
			soap_in_PointerToxsd__long(soap, NULL, NULL, "xsd:long");
			break;
		case SOAP_TYPE_PointerToxsd__string:
			soap_in_PointerToxsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_PointerTons11__FileMetaData:
			soap_in_PointerTons11__FileMetaData(soap, NULL, NULL, "ns11:FileMetaData");
			break;
		case SOAP_TYPE_PointerToArrayOfRequestFileStatus:
			soap_in_PointerToArrayOfRequestFileStatus(soap, NULL, NULL, "ns11:RequestFileStatus");
			break;
		case SOAP_TYPE_PointerTons11__RequestStatus:
			soap_in_PointerTons11__RequestStatus(soap, NULL, NULL, "ns11:RequestStatus");
			break;
		case SOAP_TYPE_xsd__dateTime:
			soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
			break;
		case SOAP_TYPE_xsd__string:
			soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			break;
		case SOAP_TYPE_string:
			soap_in_string(soap, NULL, NULL, "");
			break;
		default:
			if (!*soap->id)
			{	if (soap_ignore_element(soap))
					break;
				else
					continue;
			}
			soap_in_byte(soap, NULL, NULL, "xsd:byte");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Integer(soap, NULL, NULL, "tns:Integer");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_int(soap, NULL, NULL, "xsd:int");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Long(soap, NULL, NULL, "tns:Long");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__long(soap, NULL, NULL, "xsd:long");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_LONG64(soap, NULL, NULL, "xsd:long");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__Boolean(soap, NULL, NULL, "tns:Boolean");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__boolean(soap, NULL, NULL, "xsd:boolean");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_bool(soap, NULL, NULL, "xsd:boolean");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ArrayOfboolean(soap, NULL, NULL, "xsd:boolean");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__unPinResponse(soap, NULL, NULL, "tns:unPinResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__setFileStatusResponse(soap, NULL, NULL, "tns:setFileStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getProtocolsResponse(soap, NULL, NULL, "tns:getProtocolsResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getRequestStatusResponse(soap, NULL, NULL, "tns:getRequestStatusResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getFileMetaDataResponse(soap, NULL, NULL, "tns:getFileMetaDataResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__pingResponse(soap, NULL, NULL, "tns:pingResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__pinResponse(soap, NULL, NULL, "tns:pinResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getEstPutTimeResponse(soap, NULL, NULL, "tns:getEstPutTimeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getEstGetTimeResponse(soap, NULL, NULL, "tns:getEstGetTimeResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__copyResponse(soap, NULL, NULL, "tns:copyResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__mkPermanentResponse(soap, NULL, NULL, "tns:mkPermanentResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ns11__RequestFileStatus(soap, NULL, NULL, "ns11:RequestFileStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__putResponse(soap, NULL, NULL, "tns:putResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ArrayOflong(soap, NULL, NULL, "xsd:long");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ArrayOfstring(soap, NULL, NULL, "xsd:string");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ns11__FileMetaData(soap, NULL, NULL, "ns11:FileMetaData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ArrayOfFileMetaData(soap, NULL, NULL, "ns11:FileMetaData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ArrayOfRequestFileStatus(soap, NULL, NULL, "ns11:RequestFileStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__advisoryDeleteResponse(soap, NULL, NULL, "tns:advisoryDeleteResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_ns11__RequestStatus(soap, NULL, NULL, "ns11:RequestStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getResponse(soap, NULL, NULL, "tns:getResponse");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getFileMetaData(soap, NULL, NULL, "tns:getFileMetaData");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__get(soap, NULL, NULL, "tns:get");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__mkPermanent(soap, NULL, NULL, "tns:mkPermanent");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__setFileStatus(soap, NULL, NULL, "tns:setFileStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__unPin(soap, NULL, NULL, "tns:unPin");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__pin(soap, NULL, NULL, "tns:pin");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__advisoryDelete(soap, NULL, NULL, "tns:advisoryDelete");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getEstGetTime(soap, NULL, NULL, "tns:getEstGetTime");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getProtocols(soap, NULL, NULL, "tns:getProtocols");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__copy(soap, NULL, NULL, "tns:copy");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getRequestStatus(soap, NULL, NULL, "tns:getRequestStatus");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__put(soap, NULL, NULL, "tns:put");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__getEstPutTime(soap, NULL, NULL, "tns:getEstPutTime");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_tns__ping(soap, NULL, NULL, "tns:ping");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__dateTime(soap, NULL, NULL, "xsd:dateTime");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_xsd__string(soap, NULL, NULL, "xsd:string");
			if (soap->error == SOAP_TYPE_MISMATCH && soap->level == 2)
				soap_in_string(soap, NULL, NULL, "xsd:string");
			if (soap->error)
			{	soap->peeked = 1;
				soap_ignore_element(soap);
			}
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_NO_TAG)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version != 1 || (soap->mode & SOAP_XML_GRAPH) || (soap->mode & SOAP_XML_TREE))
		return SOAP_OK;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if ((soap->mode & SOAP_IO_LENGTH) ? pp->mark1 == 2 : pp->mark2 == 2)
				switch (pp->type)
				{
				case SOAP_TYPE_byte:
					soap_out_byte(soap, "id", pp->id, (const char *)pp->ptr, "xsd:byte");
					break;
				case SOAP_TYPE_tns__Integer:
					soap_out_tns__Integer(soap, "id", pp->id, (const int *)pp->ptr, "tns:Integer");
					break;
				case SOAP_TYPE_xsd__int:
					soap_out_xsd__int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_TYPE_int:
					soap_out_int(soap, "id", pp->id, (const int *)pp->ptr, "xsd:int");
					break;
				case SOAP_TYPE_tns__Long:
					soap_out_tns__Long(soap, "id", pp->id, (const LONG64 *)pp->ptr, "tns:Long");
					break;
				case SOAP_TYPE_xsd__long:
					soap_out_xsd__long(soap, "id", pp->id, (const LONG64 *)pp->ptr, "xsd:long");
					break;
				case SOAP_TYPE_LONG64:
					soap_out_LONG64(soap, "id", pp->id, (const LONG64 *)pp->ptr, "xsd:long");
					break;
				case SOAP_TYPE_tns__Boolean:
					soap_out_tns__Boolean(soap, "id", pp->id, (const bool *)pp->ptr, "tns:Boolean");
					break;
				case SOAP_TYPE_xsd__boolean:
					soap_out_xsd__boolean(soap, "id", pp->id, (const bool *)pp->ptr, "xsd:boolean");
					break;
				case SOAP_TYPE_bool:
					soap_out_bool(soap, "id", pp->id, (const bool *)pp->ptr, "xsd:boolean");
					break;
				case SOAP_TYPE_ArrayOfboolean:
					((ArrayOfboolean *)pp->ptr)->soap_out(soap, "id", pp->id, "xsd:boolean");
					break;
				case SOAP_TYPE_tns__unPinResponse:
					((tns__unPinResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:unPinResponse");
					break;
				case SOAP_TYPE_tns__setFileStatusResponse:
					((tns__setFileStatusResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:setFileStatusResponse");
					break;
				case SOAP_TYPE_tns__getProtocolsResponse:
					((tns__getProtocolsResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:getProtocolsResponse");
					break;
				case SOAP_TYPE_tns__getRequestStatusResponse:
					((tns__getRequestStatusResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:getRequestStatusResponse");
					break;
				case SOAP_TYPE_tns__getFileMetaDataResponse:
					((tns__getFileMetaDataResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:getFileMetaDataResponse");
					break;
				case SOAP_TYPE_tns__pingResponse:
					((tns__pingResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:pingResponse");
					break;
				case SOAP_TYPE_tns__pinResponse:
					((tns__pinResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:pinResponse");
					break;
				case SOAP_TYPE_tns__getEstPutTimeResponse:
					((tns__getEstPutTimeResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:getEstPutTimeResponse");
					break;
				case SOAP_TYPE_tns__getEstGetTimeResponse:
					((tns__getEstGetTimeResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:getEstGetTimeResponse");
					break;
				case SOAP_TYPE_tns__copyResponse:
					((tns__copyResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:copyResponse");
					break;
				case SOAP_TYPE_tns__mkPermanentResponse:
					((tns__mkPermanentResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:mkPermanentResponse");
					break;
				case SOAP_TYPE_ns11__RequestFileStatus:
					((ns11__RequestFileStatus *)pp->ptr)->soap_out(soap, "id", pp->id, "ns11:RequestFileStatus");
					break;
				case SOAP_TYPE_tns__putResponse:
					((tns__putResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:putResponse");
					break;
				case SOAP_TYPE_ArrayOflong:
					((ArrayOflong *)pp->ptr)->soap_out(soap, "id", pp->id, "xsd:long");
					break;
				case SOAP_TYPE_ArrayOfstring:
					((ArrayOfstring *)pp->ptr)->soap_out(soap, "id", pp->id, "xsd:string");
					break;
				case SOAP_TYPE_ns11__FileMetaData:
					((ns11__FileMetaData *)pp->ptr)->soap_out(soap, "id", pp->id, "ns11:FileMetaData");
					break;
				case SOAP_TYPE_ArrayOfFileMetaData:
					((ArrayOfFileMetaData *)pp->ptr)->soap_out(soap, "id", pp->id, "ns11:FileMetaData");
					break;
				case SOAP_TYPE_ArrayOfRequestFileStatus:
					((ArrayOfRequestFileStatus *)pp->ptr)->soap_out(soap, "id", pp->id, "ns11:RequestFileStatus");
					break;
				case SOAP_TYPE_tns__advisoryDeleteResponse:
					((tns__advisoryDeleteResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:advisoryDeleteResponse");
					break;
				case SOAP_TYPE_ns11__RequestStatus:
					((ns11__RequestStatus *)pp->ptr)->soap_out(soap, "id", pp->id, "ns11:RequestStatus");
					break;
				case SOAP_TYPE_tns__getResponse:
					((tns__getResponse *)pp->ptr)->soap_out(soap, "id", pp->id, "tns:getResponse");
					break;
				case SOAP_TYPE_tns__getFileMetaData:
					soap_out_tns__getFileMetaData(soap, "id", pp->id, (const struct tns__getFileMetaData *)pp->ptr, "tns:getFileMetaData");
					break;
				case SOAP_TYPE_tns__get:
					soap_out_tns__get(soap, "id", pp->id, (const struct tns__get *)pp->ptr, "tns:get");
					break;
				case SOAP_TYPE_tns__mkPermanent:
					soap_out_tns__mkPermanent(soap, "id", pp->id, (const struct tns__mkPermanent *)pp->ptr, "tns:mkPermanent");
					break;
				case SOAP_TYPE_tns__setFileStatus:
					soap_out_tns__setFileStatus(soap, "id", pp->id, (const struct tns__setFileStatus *)pp->ptr, "tns:setFileStatus");
					break;
				case SOAP_TYPE_tns__unPin:
					soap_out_tns__unPin(soap, "id", pp->id, (const struct tns__unPin *)pp->ptr, "tns:unPin");
					break;
				case SOAP_TYPE_tns__pin:
					soap_out_tns__pin(soap, "id", pp->id, (const struct tns__pin *)pp->ptr, "tns:pin");
					break;
				case SOAP_TYPE_tns__advisoryDelete:
					soap_out_tns__advisoryDelete(soap, "id", pp->id, (const struct tns__advisoryDelete *)pp->ptr, "tns:advisoryDelete");
					break;
				case SOAP_TYPE_tns__getEstGetTime:
					soap_out_tns__getEstGetTime(soap, "id", pp->id, (const struct tns__getEstGetTime *)pp->ptr, "tns:getEstGetTime");
					break;
				case SOAP_TYPE_tns__getProtocols:
					soap_out_tns__getProtocols(soap, "id", pp->id, (const struct tns__getProtocols *)pp->ptr, "tns:getProtocols");
					break;
				case SOAP_TYPE_tns__copy:
					soap_out_tns__copy(soap, "id", pp->id, (const struct tns__copy *)pp->ptr, "tns:copy");
					break;
				case SOAP_TYPE_tns__getRequestStatus:
					soap_out_tns__getRequestStatus(soap, "id", pp->id, (const struct tns__getRequestStatus *)pp->ptr, "tns:getRequestStatus");
					break;
				case SOAP_TYPE_tns__put:
					soap_out_tns__put(soap, "id", pp->id, (const struct tns__put *)pp->ptr, "tns:put");
					break;
				case SOAP_TYPE_tns__getEstPutTime:
					soap_out_tns__getEstPutTime(soap, "id", pp->id, (const struct tns__getEstPutTime *)pp->ptr, "tns:getEstPutTime");
					break;
				case SOAP_TYPE_tns__ping:
					soap_out_tns__ping(soap, "id", pp->id, (const struct tns__ping *)pp->ptr, "tns:ping");
					break;
				case SOAP_TYPE_PointerTotns__getFileMetaDataResponse:
					soap_out_PointerTotns__getFileMetaDataResponse(soap, "id", pp->id, (tns__getFileMetaDataResponse *const*)pp->ptr, "tns:getFileMetaDataResponse");
					break;
				case SOAP_TYPE_PointerTotns__getResponse:
					soap_out_PointerTotns__getResponse(soap, "id", pp->id, (tns__getResponse *const*)pp->ptr, "tns:getResponse");
					break;
				case SOAP_TYPE_PointerTotns__mkPermanentResponse:
					soap_out_PointerTotns__mkPermanentResponse(soap, "id", pp->id, (tns__mkPermanentResponse *const*)pp->ptr, "tns:mkPermanentResponse");
					break;
				case SOAP_TYPE_PointerTotns__setFileStatusResponse:
					soap_out_PointerTotns__setFileStatusResponse(soap, "id", pp->id, (tns__setFileStatusResponse *const*)pp->ptr, "tns:setFileStatusResponse");
					break;
				case SOAP_TYPE_PointerTotns__unPinResponse:
					soap_out_PointerTotns__unPinResponse(soap, "id", pp->id, (tns__unPinResponse *const*)pp->ptr, "tns:unPinResponse");
					break;
				case SOAP_TYPE_PointerTotns__pinResponse:
					soap_out_PointerTotns__pinResponse(soap, "id", pp->id, (tns__pinResponse *const*)pp->ptr, "tns:pinResponse");
					break;
				case SOAP_TYPE_PointerTotns__advisoryDeleteResponse:
					soap_out_PointerTotns__advisoryDeleteResponse(soap, "id", pp->id, (tns__advisoryDeleteResponse *const*)pp->ptr, "tns:advisoryDeleteResponse");
					break;
				case SOAP_TYPE_PointerTotns__getEstGetTimeResponse:
					soap_out_PointerTotns__getEstGetTimeResponse(soap, "id", pp->id, (tns__getEstGetTimeResponse *const*)pp->ptr, "tns:getEstGetTimeResponse");
					break;
				case SOAP_TYPE_PointerTotns__getProtocolsResponse:
					soap_out_PointerTotns__getProtocolsResponse(soap, "id", pp->id, (tns__getProtocolsResponse *const*)pp->ptr, "tns:getProtocolsResponse");
					break;
				case SOAP_TYPE_PointerTotns__copyResponse:
					soap_out_PointerTotns__copyResponse(soap, "id", pp->id, (tns__copyResponse *const*)pp->ptr, "tns:copyResponse");
					break;
				case SOAP_TYPE_PointerTotns__getRequestStatusResponse:
					soap_out_PointerTotns__getRequestStatusResponse(soap, "id", pp->id, (tns__getRequestStatusResponse *const*)pp->ptr, "tns:getRequestStatusResponse");
					break;
				case SOAP_TYPE_PointerTotns__putResponse:
					soap_out_PointerTotns__putResponse(soap, "id", pp->id, (tns__putResponse *const*)pp->ptr, "tns:putResponse");
					break;
				case SOAP_TYPE_PointerTotns__getEstPutTimeResponse:
					soap_out_PointerTotns__getEstPutTimeResponse(soap, "id", pp->id, (tns__getEstPutTimeResponse *const*)pp->ptr, "tns:getEstPutTimeResponse");
					break;
				case SOAP_TYPE_PointerToArrayOfboolean:
					soap_out_PointerToArrayOfboolean(soap, "id", pp->id, (ArrayOfboolean *const*)pp->ptr, "xsd:boolean");
					break;
				case SOAP_TYPE_PointerToArrayOflong:
					soap_out_PointerToArrayOflong(soap, "id", pp->id, (ArrayOflong *const*)pp->ptr, "xsd:long");
					break;
				case SOAP_TYPE_PointerTotns__pingResponse:
					soap_out_PointerTotns__pingResponse(soap, "id", pp->id, (tns__pingResponse *const*)pp->ptr, "tns:pingResponse");
					break;
				case SOAP_TYPE_PointerToxsd__boolean:
					soap_out_PointerToxsd__boolean(soap, "id", pp->id, (bool *const*)pp->ptr, "xsd:boolean");
					break;
				case SOAP_TYPE_PointerToArrayOfstring:
					soap_out_PointerToArrayOfstring(soap, "id", pp->id, (ArrayOfstring *const*)pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_PointerToArrayOfFileMetaData:
					soap_out_PointerToArrayOfFileMetaData(soap, "id", pp->id, (ArrayOfFileMetaData *const*)pp->ptr, "ns11:FileMetaData");
					break;
				case SOAP_TYPE_PointerTons11__RequestFileStatus:
					soap_out_PointerTons11__RequestFileStatus(soap, "id", pp->id, (ns11__RequestFileStatus *const*)pp->ptr, "ns11:RequestFileStatus");
					break;
				case SOAP_TYPE_PointerToxsd__long:
					soap_out_PointerToxsd__long(soap, "id", pp->id, (LONG64 *const*)pp->ptr, "xsd:long");
					break;
				case SOAP_TYPE_PointerToxsd__string:
					soap_out_PointerToxsd__string(soap, "id", pp->id, (char **const*)pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_PointerTons11__FileMetaData:
					soap_out_PointerTons11__FileMetaData(soap, "id", pp->id, (ns11__FileMetaData *const*)pp->ptr, "ns11:FileMetaData");
					break;
				case SOAP_TYPE_PointerToArrayOfRequestFileStatus:
					soap_out_PointerToArrayOfRequestFileStatus(soap, "id", pp->id, (ArrayOfRequestFileStatus *const*)pp->ptr, "ns11:RequestFileStatus");
					break;
				case SOAP_TYPE_PointerTons11__RequestStatus:
					soap_out_PointerTons11__RequestStatus(soap, "id", pp->id, (ns11__RequestStatus *const*)pp->ptr, "ns11:RequestStatus");
					break;
				case SOAP_TYPE_xsd__dateTime:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:dateTime");
					break;
				case SOAP_TYPE_xsd__string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				case SOAP_TYPE_string:
					soap_out_string(soap, "id", pp->id, (char**)&pp->ptr, "xsd:string");
					break;
				}
		
	return SOAP_OK;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_getattachments(struct soap *soap)
{
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	while (soap->dime_flags & SOAP_DIME_CF)
	{	if (soap_getdimehdr(soap))
			return soap->error;
		if (soap_move(soap, soap->dime_size))
			return soap->error = SOAP_EOF;
	}
	if (soap_move(soap, ((soap->dime_size+3)&-4)-soap_tell(soap)))
		return soap->error = SOAP_EOF;
	for (;;)
	{	if (soap_getdime(soap) || !soap->dime_id)
			break;
		switch (soap_lookup_type(soap, soap->dime_id))
		{
		case SOAP_TYPE_xsd__dateTime:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__dateTime, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_xsd__string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_xsd__string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		case SOAP_TYPE_string:
		{	char ** a;
			a = (char **)soap_id_enter(soap, soap->dime_id, NULL, SOAP_TYPE_string, sizeof(char *), 0);
			if (a)
				*a = soap->dime_ptr;
			break;
		}
		default:
			soap->error = SOAP_DIME_ERROR;
		}
		if (soap->error)
			break;
	}
	if (soap->error == SOAP_EOD)
		soap->error = SOAP_OK;
	return soap->error;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_putattachments(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (!(soap->mode & SOAP_ENC_DIME))
		return SOAP_OK;
	if (soap_send_raw(soap, "\0\0\0", -(int)soap->count&3))
		return soap->error;
	for (i = 0; i < SOAP_PTRHASH; i++)
		for (pp = soap->pht[i]; pp; pp = pp->next)
			if (pp->mark2 == 3)
				switch (pp->type)
				{
				}
		
	return SOAP_OK;
}

SOAP_FMAC1 void * SOAP_FMAC2 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType)
{
	switch (t)
	{
	case SOAP_TYPE_tns__getResponse:
		return (void*)soap_instantiate_tns__getResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_ns11__RequestStatus:
		return (void*)soap_instantiate_ns11__RequestStatus(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__advisoryDeleteResponse:
		return (void*)soap_instantiate_tns__advisoryDeleteResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_ArrayOfRequestFileStatus:
		return (void*)soap_instantiate_ArrayOfRequestFileStatus(soap, -1, type, arrayType);
	case SOAP_TYPE_ArrayOfFileMetaData:
		return (void*)soap_instantiate_ArrayOfFileMetaData(soap, -1, type, arrayType);
	case SOAP_TYPE_ns11__FileMetaData:
		return (void*)soap_instantiate_ns11__FileMetaData(soap, -1, type, arrayType);
	case SOAP_TYPE_ArrayOfstring:
		return (void*)soap_instantiate_ArrayOfstring(soap, -1, type, arrayType);
	case SOAP_TYPE_ArrayOflong:
		return (void*)soap_instantiate_ArrayOflong(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__putResponse:
		return (void*)soap_instantiate_tns__putResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_ns11__RequestFileStatus:
		return (void*)soap_instantiate_ns11__RequestFileStatus(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__mkPermanentResponse:
		return (void*)soap_instantiate_tns__mkPermanentResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__copyResponse:
		return (void*)soap_instantiate_tns__copyResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__getEstGetTimeResponse:
		return (void*)soap_instantiate_tns__getEstGetTimeResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__getEstPutTimeResponse:
		return (void*)soap_instantiate_tns__getEstPutTimeResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__pinResponse:
		return (void*)soap_instantiate_tns__pinResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__pingResponse:
		return (void*)soap_instantiate_tns__pingResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__getFileMetaDataResponse:
		return (void*)soap_instantiate_tns__getFileMetaDataResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__getRequestStatusResponse:
		return (void*)soap_instantiate_tns__getRequestStatusResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__getProtocolsResponse:
		return (void*)soap_instantiate_tns__getProtocolsResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__setFileStatusResponse:
		return (void*)soap_instantiate_tns__setFileStatusResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_tns__unPinResponse:
		return (void*)soap_instantiate_tns__unPinResponse(soap, -1, type, arrayType);
	case SOAP_TYPE_ArrayOfboolean:
		return (void*)soap_instantiate_ArrayOfboolean(soap, -1, type, arrayType);
	}
	return NULL;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_delete(struct soap *soap, void *p)
{
	struct soap_clist **cp;
	cp = &soap->clist;
	while (*cp)
	{	if (!p || p == (*cp)->ptr)
		{	struct soap_clist *q = *cp;
			*cp = q->next;
			switch (q->type)
			{
			case SOAP_TYPE_tns__getResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getResponse*)q->ptr;
				else
					delete[] (tns__getResponse*)q->ptr;
				break;
			case SOAP_TYPE_ns11__RequestStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ns11__RequestStatus, %d)\n", q->size));
				if (q->size < 0)
					delete (ns11__RequestStatus*)q->ptr;
				else
					delete[] (ns11__RequestStatus*)q->ptr;
				break;
			case SOAP_TYPE_tns__advisoryDeleteResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__advisoryDeleteResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__advisoryDeleteResponse*)q->ptr;
				else
					delete[] (tns__advisoryDeleteResponse*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfRequestFileStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfRequestFileStatus, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfRequestFileStatus*)q->ptr;
				else
					delete[] (ArrayOfRequestFileStatus*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfFileMetaData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfFileMetaData, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfFileMetaData*)q->ptr;
				else
					delete[] (ArrayOfFileMetaData*)q->ptr;
				break;
			case SOAP_TYPE_ns11__FileMetaData:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ns11__FileMetaData, %d)\n", q->size));
				if (q->size < 0)
					delete (ns11__FileMetaData*)q->ptr;
				else
					delete[] (ns11__FileMetaData*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfstring:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfstring, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfstring*)q->ptr;
				else
					delete[] (ArrayOfstring*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOflong:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOflong, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOflong*)q->ptr;
				else
					delete[] (ArrayOflong*)q->ptr;
				break;
			case SOAP_TYPE_tns__putResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__putResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__putResponse*)q->ptr;
				else
					delete[] (tns__putResponse*)q->ptr;
				break;
			case SOAP_TYPE_ns11__RequestFileStatus:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ns11__RequestFileStatus, %d)\n", q->size));
				if (q->size < 0)
					delete (ns11__RequestFileStatus*)q->ptr;
				else
					delete[] (ns11__RequestFileStatus*)q->ptr;
				break;
			case SOAP_TYPE_tns__mkPermanentResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__mkPermanentResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__mkPermanentResponse*)q->ptr;
				else
					delete[] (tns__mkPermanentResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__copyResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__copyResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__copyResponse*)q->ptr;
				else
					delete[] (tns__copyResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getEstGetTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getEstGetTimeResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getEstGetTimeResponse*)q->ptr;
				else
					delete[] (tns__getEstGetTimeResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getEstPutTimeResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getEstPutTimeResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getEstPutTimeResponse*)q->ptr;
				else
					delete[] (tns__getEstPutTimeResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__pinResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__pinResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__pinResponse*)q->ptr;
				else
					delete[] (tns__pinResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__pingResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__pingResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__pingResponse*)q->ptr;
				else
					delete[] (tns__pingResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getFileMetaDataResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getFileMetaDataResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getFileMetaDataResponse*)q->ptr;
				else
					delete[] (tns__getFileMetaDataResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getRequestStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getRequestStatusResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getRequestStatusResponse*)q->ptr;
				else
					delete[] (tns__getRequestStatusResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__getProtocolsResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__getProtocolsResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__getProtocolsResponse*)q->ptr;
				else
					delete[] (tns__getProtocolsResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__setFileStatusResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__setFileStatusResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__setFileStatusResponse*)q->ptr;
				else
					delete[] (tns__setFileStatusResponse*)q->ptr;
				break;
			case SOAP_TYPE_tns__unPinResponse:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(tns__unPinResponse, %d)\n", q->size));
				if (q->size < 0)
					delete (tns__unPinResponse*)q->ptr;
				else
					delete[] (tns__unPinResponse*)q->ptr;
				break;
			case SOAP_TYPE_ArrayOfboolean:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_delete(ArrayOfboolean, %d)\n", q->size));
				if (q->size < 0)
					delete (ArrayOfboolean*)q->ptr;
				else
					delete[] (ArrayOfboolean*)q->ptr;
				break;
			}
			free(q);
			if (p)
				return;
			cp = &soap->clist;
		}
		else
			cp = &(*cp)->next;
	}
}

SOAP_FMAC1 void* SOAP_FMAC2 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, const char *type, const char *arrayType)
{	struct soap_ilist *ip;
	DBGLOG(TEST,SOAP_MESSAGE(fdebug, "Class id enter id='%s' t=%d loc=%p type='%s' arrayType='%s'\n", id, t, p, type?type:"", arrayType?arrayType:""));
	soap->alloced = 0;
	if (*id == '\0')
	{	if (!p)
			return soap_instantiate(soap, t, type, arrayType);
		else
			return p;
	}
	ip = soap_lookup(soap, id);
	if (!ip)
	{	ip = soap_enter(soap, id);
		ip->link = NULL;
		ip->copy = NULL;
		if (!p)
			p = soap_instantiate(soap, t, type, arrayType);
		ip->ptr = p;
		ip->level = 0;
	}
	else if (ip->ptr)
	{	if (p)
		{	soap->error = SOAP_MULTI_ID;
			return NULL;
		}
	}
	else
	{	if (!p)
			p = soap_instantiate(soap, t, type, arrayType);
		ip->ptr = p;
		ip->level = 0;
		if (!soap->blist)
			soap_resolve_ptr(ip);
	}
	return ip->ptr;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_byte(struct soap *soap, char *a)
{
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_byte(struct soap *soap, char const*a)
{
	soap_reference(soap, a, SOAP_TYPE_byte);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_byte(struct soap *soap, char *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_byte, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_byte(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_byte(soap, tag, i, a, type);
		}
	else
		soap_out_byte(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * SOAP_FMAC2 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Integer(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_tns__Integer
	*a = SOAP_DEFAULT_tns__Integer;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Integer(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_tns__Integer);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Integer(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Integer, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Integer(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Integer(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Integer(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Integer(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_tns__Integer);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_tns__Integer(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_tns__Integer(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_tns__Integer);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_xsd__int
	*a = SOAP_DEFAULT_xsd__int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__int(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__int(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_xsd__int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_xsd__int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_int(struct soap *soap, int *a)
{
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_int(struct soap *soap, int const*a)
{
	soap_reference(soap, a, SOAP_TYPE_int);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_int(struct soap *soap, int *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_int, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_int(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_int(soap, tag, i, a, type);
		}
	else
		soap_out_int(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int * SOAP_FMAC2 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Long(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_tns__Long
	*a = SOAP_DEFAULT_tns__Long;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Long(struct soap *soap, LONG64 const*a)
{
	soap_reference(soap, a, SOAP_TYPE_tns__Long);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Long(struct soap *soap, LONG64 *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Long, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Long(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Long(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Long(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Long(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_tns__Long);
}

SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_get_tns__Long(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_in_tns__Long(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_tns__Long);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__long(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_xsd__long
	*a = SOAP_DEFAULT_xsd__long;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__long(struct soap *soap, LONG64 const*a)
{
	soap_reference(soap, a, SOAP_TYPE_xsd__long);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__long(struct soap *soap, LONG64 *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__long, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__long(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__long(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__long(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__long(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_get_xsd__long(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_in_xsd__long(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_xsd__long);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_LONG64(struct soap *soap, LONG64 *a)
{
#ifdef SOAP_DEFAULT_LONG64
	*a = SOAP_DEFAULT_LONG64;
#else
	*a = (LONG64)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_LONG64(struct soap *soap, LONG64 const*a)
{
	soap_reference(soap, a, SOAP_TYPE_LONG64);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_LONG64(struct soap *soap, LONG64 *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_LONG64, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_LONG64(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_LONG64(soap, tag, i, a, type);
		}
	else
		soap_out_LONG64(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_LONG64(struct soap *soap, const char *tag, int id, const LONG64 *a, const char *type)
{
	return soap_outLONG64(soap, tag, id, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_get_LONG64(struct soap *soap, LONG64 *p, const char *tag, const char *type)
{
	if ((p = soap_in_LONG64(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 LONG64 * SOAP_FMAC2 soap_in_LONG64(struct soap *soap, const char *tag, LONG64 *a, const char *type)
{
	return soap_inLONG64(soap, tag, a, type, SOAP_TYPE_LONG64);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__Boolean(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_tns__Boolean
	*a = SOAP_DEFAULT_tns__Boolean;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__Boolean(struct soap *soap, bool const*a)
{
	soap_reference(soap, a, SOAP_TYPE_tns__Boolean);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__Boolean(struct soap *soap, bool *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__Boolean, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__Boolean(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__Boolean(soap, tag, i, a, type);
		}
	else
		soap_out_tns__Boolean(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 const char* SOAP_FMAC2 soap_tns__Boolean2s(struct soap *soap, bool n)
{	switch (n)
	{
		case false: return "false";
		case true: return "true";
	}

	sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, (LONG64)n);
	return soap->tmpbuf;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__Boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__Boolean), type);
	soap_send(soap, soap_tns__Boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_get_tns__Boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__Boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_s2tns__Boolean(struct soap *soap, const char *s, bool *a)
{
	if (!strcmp(s, "false"))
		*a = false;
	else if (!strcmp(s, "true"))
		*a = true;
	else 
	{	char *r;
		*a = (bool)strtol(s, &r, 10);
		if (*r)
			return soap->error = SOAP_TYPE_MISMATCH;
	}
	return SOAP_OK;
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_in_tns__Boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
	soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Boolean, sizeof(bool), 0);
		if (!a || soap_s2tns__Boolean(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__Boolean, sizeof(bool), 0), SOAP_TYPE_tns__Boolean, sizeof(bool));
		if (soap->alloced)
			soap_default_tns__Boolean(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__boolean(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_xsd__boolean
	*a = SOAP_DEFAULT_xsd__boolean;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__boolean(struct soap *soap, bool const*a)
{
	soap_reference(soap, a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__boolean(struct soap *soap, bool *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__boolean, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__boolean(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__boolean(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__boolean(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 const char* SOAP_FMAC2 soap_xsd__boolean2s(struct soap *soap, bool n)
{	switch (n)
	{
		case false: return "false";
		case true: return "true";
	}

	sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, (LONG64)n);
	return soap->tmpbuf;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__boolean(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_xsd__boolean), type);
	soap_send(soap, soap_xsd__boolean2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_get_xsd__boolean(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_s2xsd__boolean(struct soap *soap, const char *s, bool *a)
{
	if (!strcmp(s, "false"))
		*a = false;
	else if (!strcmp(s, "true"))
		*a = true;
	else 
	{	char *r;
		*a = (bool)strtol(s, &r, 10);
		if (*r)
			return soap->error = SOAP_TYPE_MISMATCH;
	}
	return SOAP_OK;
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_in_xsd__boolean(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
	soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), 0);
		if (!a || soap_s2xsd__boolean(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_xsd__boolean, sizeof(bool), 0), SOAP_TYPE_xsd__boolean, sizeof(bool));
		if (soap->alloced)
			soap_default_xsd__boolean(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_bool(struct soap *soap, bool *a)
{
#ifdef SOAP_DEFAULT_bool
	*a = SOAP_DEFAULT_bool;
#else
	*a = (bool)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_bool(struct soap *soap, bool const*a)
{
	soap_reference(soap, a, SOAP_TYPE_bool);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_bool(struct soap *soap, bool *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_bool, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_bool(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_bool(soap, tag, i, a, type);
		}
	else
		soap_out_bool(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 const char* SOAP_FMAC2 soap_bool2s(struct soap *soap, bool n)
{	switch (n)
	{
		case false: return "false";
		case true: return "true";
	}

	sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, (LONG64)n);
	return soap->tmpbuf;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_bool(struct soap *soap, const char *tag, int id, const bool *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_bool), type);
	soap_send(soap, soap_bool2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_get_bool(struct soap *soap, bool *p, const char *tag, const char *type)
{
	if ((p = soap_in_bool(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_s2bool(struct soap *soap, const char *s, bool *a)
{
	if (!strcmp(s, "false"))
		*a = false;
	else if (!strcmp(s, "true"))
		*a = true;
	else 
	{	char *r;
		*a = (bool)strtol(s, &r, 10);
		if (*r)
			return soap->error = SOAP_TYPE_MISMATCH;
	}
	return SOAP_OK;
}

SOAP_FMAC1 bool * SOAP_FMAC2 soap_in_bool(struct soap *soap, const char *tag, bool *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
	soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (soap->body && !*soap->href)
	{	a = (bool *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0);
		if (!a || soap_s2bool(soap, soap_value(soap), a))
			return NULL;
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (bool *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_bool, sizeof(bool), 0), SOAP_TYPE_bool, sizeof(bool));
		if (soap->alloced)
			soap_default_bool(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ArrayOfboolean::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfboolean::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfboolean))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_xsd__boolean);
		}
}

void ArrayOfboolean::soap_default(struct soap *soap)
{
	static ArrayOfboolean a;
	memcpy(this, &a, sizeof(ArrayOfboolean));
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfboolean::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfboolean, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ArrayOfboolean::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfboolean(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ArrayOfboolean(struct soap *soap, const char *tag, int id, const ArrayOfboolean *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "xsd:boolean", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfboolean, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		soap_out_xsd__boolean(soap, "item", 0, &a->__ptr[i], "xsd:boolean");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfboolean::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfboolean(soap, this, tag, type);
}

SOAP_FMAC1 ArrayOfboolean * SOAP_FMAC2 soap_get_ArrayOfboolean(struct soap *soap, ArrayOfboolean *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfboolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfboolean::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfboolean(soap, tag, this, type);
}

SOAP_FMAC1 ArrayOfboolean * SOAP_FMAC2 soap_in_ArrayOfboolean(struct soap *soap, const char *tag, ArrayOfboolean *a, const char *type)
{	int i, j;
	bool *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfboolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfboolean, soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfboolean *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfboolean, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = (bool *)soap_malloc(soap, sizeof(bool) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_xsd__boolean(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_xsd__boolean(soap, NULL, a->__ptr+i, "xsd:boolean"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (bool *)soap_push_block(soap, sizeof(bool));
				if (!p)
					return NULL;
				soap_default_xsd__boolean(soap, p);
				if (!soap_in_xsd__boolean(soap, NULL, p, "xsd:boolean"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (bool *)soap_malloc(soap, soap->blist->size);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfboolean *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfboolean, soap->type, soap->arrayType), SOAP_TYPE_ArrayOfboolean, sizeof(ArrayOfboolean));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 ArrayOfboolean * SOAP_FMAC2 soap_instantiate_ArrayOfboolean(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfboolean(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ArrayOfboolean;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfboolean;
	}
	else
	{	cp->ptr = (void*)new ArrayOfboolean[n];
	}
	return (ArrayOfboolean*)cp->ptr;
}

void tns__unPinResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__unPinResponse))
		this->soap_mark(soap);
}

void tns__unPinResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__unPinResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__unPinResponse*)this)->_Result);
}

void tns__unPinResponse::soap_default(struct soap *soap)
{
	static tns__unPinResponse a;
	memcpy(this, &a, sizeof(tns__unPinResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__unPinResponse*)this)->_Result);
}

int tns__unPinResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__unPinResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__unPinResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__unPinResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__unPinResponse(struct soap *soap, const char *tag, int id, const tns__unPinResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__unPinResponse), "tns:unPinResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__unPinResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__unPinResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__unPinResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__unPinResponse * SOAP_FMAC2 soap_get_tns__unPinResponse(struct soap *soap, tns__unPinResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__unPinResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__unPinResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__unPinResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__unPinResponse * SOAP_FMAC2 soap_in_tns__unPinResponse(struct soap *soap, const char *tag, tns__unPinResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__unPinResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__unPinResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__unPinResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__unPinResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__unPinResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__unPinResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__unPinResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__unPinResponse, sizeof(tns__unPinResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__unPinResponse * SOAP_FMAC2 soap_instantiate_tns__unPinResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__unPinResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__unPinResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__unPinResponse;
	}
	else
	{	cp->ptr = (void*)new tns__unPinResponse[n];
	}
	return (tns__unPinResponse*)cp->ptr;
}

void tns__setFileStatusResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__setFileStatusResponse))
		this->soap_mark(soap);
}

void tns__setFileStatusResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__setFileStatusResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__setFileStatusResponse*)this)->_Result);
}

void tns__setFileStatusResponse::soap_default(struct soap *soap)
{
	static tns__setFileStatusResponse a;
	memcpy(this, &a, sizeof(tns__setFileStatusResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__setFileStatusResponse*)this)->_Result);
}

int tns__setFileStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__setFileStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__setFileStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__setFileStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__setFileStatusResponse(struct soap *soap, const char *tag, int id, const tns__setFileStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__setFileStatusResponse), "tns:setFileStatusResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__setFileStatusResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__setFileStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__setFileStatusResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__setFileStatusResponse * SOAP_FMAC2 soap_get_tns__setFileStatusResponse(struct soap *soap, tns__setFileStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setFileStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__setFileStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__setFileStatusResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__setFileStatusResponse * SOAP_FMAC2 soap_in_tns__setFileStatusResponse(struct soap *soap, const char *tag, tns__setFileStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__setFileStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setFileStatusResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__setFileStatusResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__setFileStatusResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__setFileStatusResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__setFileStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setFileStatusResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__setFileStatusResponse, sizeof(tns__setFileStatusResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__setFileStatusResponse * SOAP_FMAC2 soap_instantiate_tns__setFileStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__setFileStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__setFileStatusResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__setFileStatusResponse;
	}
	else
	{	cp->ptr = (void*)new tns__setFileStatusResponse[n];
	}
	return (tns__setFileStatusResponse*)cp->ptr;
}

void tns__getProtocolsResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getProtocolsResponse))
		this->soap_mark(soap);
}

void tns__getProtocolsResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getProtocolsResponse*)this)->_Result, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &((tns__getProtocolsResponse*)this)->_Result);
}

void tns__getProtocolsResponse::soap_default(struct soap *soap)
{
	static tns__getProtocolsResponse a;
	memcpy(this, &a, sizeof(tns__getProtocolsResponse));
	soap_default_PointerToArrayOfstring(soap, &((tns__getProtocolsResponse*)this)->_Result);
}

int tns__getProtocolsResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__getProtocolsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__getProtocolsResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getProtocolsResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getProtocolsResponse(struct soap *soap, const char *tag, int id, const tns__getProtocolsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getProtocolsResponse), "tns:getProtocolsResponse");
	soap_out_PointerToArrayOfstring(soap, "Result", -1, &(((tns__getProtocolsResponse*)a)->_Result), "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getProtocolsResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getProtocolsResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__getProtocolsResponse * SOAP_FMAC2 soap_get_tns__getProtocolsResponse(struct soap *soap, tns__getProtocolsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getProtocolsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getProtocolsResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getProtocolsResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__getProtocolsResponse * SOAP_FMAC2 soap_in_tns__getProtocolsResponse(struct soap *soap, const char *tag, tns__getProtocolsResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getProtocolsResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getProtocolsResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getProtocolsResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getProtocolsResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, NULL, &(((tns__getProtocolsResponse*)a)->_Result), "xsd:string"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getProtocolsResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getProtocolsResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__getProtocolsResponse, sizeof(tns__getProtocolsResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__getProtocolsResponse * SOAP_FMAC2 soap_instantiate_tns__getProtocolsResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getProtocolsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__getProtocolsResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getProtocolsResponse;
	}
	else
	{	cp->ptr = (void*)new tns__getProtocolsResponse[n];
	}
	return (tns__getProtocolsResponse*)cp->ptr;
}

void tns__getRequestStatusResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getRequestStatusResponse))
		this->soap_mark(soap);
}

void tns__getRequestStatusResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getRequestStatusResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__getRequestStatusResponse*)this)->_Result);
}

void tns__getRequestStatusResponse::soap_default(struct soap *soap)
{
	static tns__getRequestStatusResponse a;
	memcpy(this, &a, sizeof(tns__getRequestStatusResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__getRequestStatusResponse*)this)->_Result);
}

int tns__getRequestStatusResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__getRequestStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__getRequestStatusResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getRequestStatusResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getRequestStatusResponse(struct soap *soap, const char *tag, int id, const tns__getRequestStatusResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getRequestStatusResponse), "tns:getRequestStatusResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__getRequestStatusResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getRequestStatusResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getRequestStatusResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__getRequestStatusResponse * SOAP_FMAC2 soap_get_tns__getRequestStatusResponse(struct soap *soap, tns__getRequestStatusResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getRequestStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getRequestStatusResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getRequestStatusResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__getRequestStatusResponse * SOAP_FMAC2 soap_in_tns__getRequestStatusResponse(struct soap *soap, const char *tag, tns__getRequestStatusResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getRequestStatusResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getRequestStatusResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getRequestStatusResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getRequestStatusResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__getRequestStatusResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getRequestStatusResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getRequestStatusResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__getRequestStatusResponse, sizeof(tns__getRequestStatusResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__getRequestStatusResponse * SOAP_FMAC2 soap_instantiate_tns__getRequestStatusResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getRequestStatusResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__getRequestStatusResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getRequestStatusResponse;
	}
	else
	{	cp->ptr = (void*)new tns__getRequestStatusResponse[n];
	}
	return (tns__getRequestStatusResponse*)cp->ptr;
}

void tns__getFileMetaDataResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getFileMetaDataResponse))
		this->soap_mark(soap);
}

void tns__getFileMetaDataResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getFileMetaDataResponse*)this)->_Result, SOAP_TYPE_PointerToArrayOfFileMetaData);
	soap_mark_PointerToArrayOfFileMetaData(soap, &((tns__getFileMetaDataResponse*)this)->_Result);
}

void tns__getFileMetaDataResponse::soap_default(struct soap *soap)
{
	static tns__getFileMetaDataResponse a;
	memcpy(this, &a, sizeof(tns__getFileMetaDataResponse));
	soap_default_PointerToArrayOfFileMetaData(soap, &((tns__getFileMetaDataResponse*)this)->_Result);
}

int tns__getFileMetaDataResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__getFileMetaDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__getFileMetaDataResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getFileMetaDataResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getFileMetaDataResponse(struct soap *soap, const char *tag, int id, const tns__getFileMetaDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getFileMetaDataResponse), "tns:getFileMetaDataResponse");
	soap_out_PointerToArrayOfFileMetaData(soap, "Result", -1, &(((tns__getFileMetaDataResponse*)a)->_Result), "ns11:FileMetaData");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getFileMetaDataResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getFileMetaDataResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__getFileMetaDataResponse * SOAP_FMAC2 soap_get_tns__getFileMetaDataResponse(struct soap *soap, tns__getFileMetaDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getFileMetaDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getFileMetaDataResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getFileMetaDataResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__getFileMetaDataResponse * SOAP_FMAC2 soap_in_tns__getFileMetaDataResponse(struct soap *soap, const char *tag, tns__getFileMetaDataResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getFileMetaDataResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getFileMetaDataResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getFileMetaDataResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getFileMetaDataResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfFileMetaData(soap, NULL, &(((tns__getFileMetaDataResponse*)a)->_Result), "ns11:FileMetaData"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getFileMetaDataResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getFileMetaDataResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__getFileMetaDataResponse, sizeof(tns__getFileMetaDataResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__getFileMetaDataResponse * SOAP_FMAC2 soap_instantiate_tns__getFileMetaDataResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getFileMetaDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__getFileMetaDataResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getFileMetaDataResponse;
	}
	else
	{	cp->ptr = (void*)new tns__getFileMetaDataResponse[n];
	}
	return (tns__getFileMetaDataResponse*)cp->ptr;
}

void tns__pingResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__pingResponse))
		this->soap_mark(soap);
}

void tns__pingResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__pingResponse*)this)->_Result, SOAP_TYPE_xsd__boolean);
}

void tns__pingResponse::soap_default(struct soap *soap)
{
	static tns__pingResponse a;
	memcpy(this, &a, sizeof(tns__pingResponse));
	soap_default_xsd__boolean(soap, &((tns__pingResponse*)this)->_Result);
}

int tns__pingResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__pingResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__pingResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__pingResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__pingResponse(struct soap *soap, const char *tag, int id, const tns__pingResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__pingResponse), "tns:pingResponse");
	soap_out_xsd__boolean(soap, "Result", -1, &(((tns__pingResponse*)a)->_Result), "xsd:boolean");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__pingResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__pingResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__pingResponse * SOAP_FMAC2 soap_get_tns__pingResponse(struct soap *soap, tns__pingResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__pingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__pingResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__pingResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__pingResponse * SOAP_FMAC2 soap_in_tns__pingResponse(struct soap *soap, const char *tag, tns__pingResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__pingResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__pingResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__pingResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__pingResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, NULL, &(((tns__pingResponse*)a)->_Result), "xsd:boolean"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__pingResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__pingResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__pingResponse, sizeof(tns__pingResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__pingResponse * SOAP_FMAC2 soap_instantiate_tns__pingResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__pingResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__pingResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__pingResponse;
	}
	else
	{	cp->ptr = (void*)new tns__pingResponse[n];
	}
	return (tns__pingResponse*)cp->ptr;
}

void tns__pinResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__pinResponse))
		this->soap_mark(soap);
}

void tns__pinResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__pinResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__pinResponse*)this)->_Result);
}

void tns__pinResponse::soap_default(struct soap *soap)
{
	static tns__pinResponse a;
	memcpy(this, &a, sizeof(tns__pinResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__pinResponse*)this)->_Result);
}

int tns__pinResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__pinResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__pinResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__pinResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__pinResponse(struct soap *soap, const char *tag, int id, const tns__pinResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__pinResponse), "tns:pinResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__pinResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__pinResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__pinResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__pinResponse * SOAP_FMAC2 soap_get_tns__pinResponse(struct soap *soap, tns__pinResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__pinResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__pinResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__pinResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__pinResponse * SOAP_FMAC2 soap_in_tns__pinResponse(struct soap *soap, const char *tag, tns__pinResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__pinResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__pinResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__pinResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__pinResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__pinResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__pinResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__pinResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__pinResponse, sizeof(tns__pinResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__pinResponse * SOAP_FMAC2 soap_instantiate_tns__pinResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__pinResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__pinResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__pinResponse;
	}
	else
	{	cp->ptr = (void*)new tns__pinResponse[n];
	}
	return (tns__pinResponse*)cp->ptr;
}

void tns__getEstPutTimeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getEstPutTimeResponse))
		this->soap_mark(soap);
}

void tns__getEstPutTimeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getEstPutTimeResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__getEstPutTimeResponse*)this)->_Result);
}

void tns__getEstPutTimeResponse::soap_default(struct soap *soap)
{
	static tns__getEstPutTimeResponse a;
	memcpy(this, &a, sizeof(tns__getEstPutTimeResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__getEstPutTimeResponse*)this)->_Result);
}

int tns__getEstPutTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__getEstPutTimeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__getEstPutTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getEstPutTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getEstPutTimeResponse(struct soap *soap, const char *tag, int id, const tns__getEstPutTimeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getEstPutTimeResponse), "tns:getEstPutTimeResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__getEstPutTimeResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getEstPutTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getEstPutTimeResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__getEstPutTimeResponse * SOAP_FMAC2 soap_get_tns__getEstPutTimeResponse(struct soap *soap, tns__getEstPutTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getEstPutTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getEstPutTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getEstPutTimeResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__getEstPutTimeResponse * SOAP_FMAC2 soap_in_tns__getEstPutTimeResponse(struct soap *soap, const char *tag, tns__getEstPutTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getEstPutTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstPutTimeResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getEstPutTimeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getEstPutTimeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__getEstPutTimeResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getEstPutTimeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstPutTimeResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__getEstPutTimeResponse, sizeof(tns__getEstPutTimeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__getEstPutTimeResponse * SOAP_FMAC2 soap_instantiate_tns__getEstPutTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getEstPutTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__getEstPutTimeResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getEstPutTimeResponse;
	}
	else
	{	cp->ptr = (void*)new tns__getEstPutTimeResponse[n];
	}
	return (tns__getEstPutTimeResponse*)cp->ptr;
}

void tns__getEstGetTimeResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getEstGetTimeResponse))
		this->soap_mark(soap);
}

void tns__getEstGetTimeResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getEstGetTimeResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__getEstGetTimeResponse*)this)->_Result);
}

void tns__getEstGetTimeResponse::soap_default(struct soap *soap)
{
	static tns__getEstGetTimeResponse a;
	memcpy(this, &a, sizeof(tns__getEstGetTimeResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__getEstGetTimeResponse*)this)->_Result);
}

int tns__getEstGetTimeResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__getEstGetTimeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__getEstGetTimeResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getEstGetTimeResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getEstGetTimeResponse(struct soap *soap, const char *tag, int id, const tns__getEstGetTimeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getEstGetTimeResponse), "tns:getEstGetTimeResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__getEstGetTimeResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getEstGetTimeResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getEstGetTimeResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__getEstGetTimeResponse * SOAP_FMAC2 soap_get_tns__getEstGetTimeResponse(struct soap *soap, tns__getEstGetTimeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getEstGetTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getEstGetTimeResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getEstGetTimeResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__getEstGetTimeResponse * SOAP_FMAC2 soap_in_tns__getEstGetTimeResponse(struct soap *soap, const char *tag, tns__getEstGetTimeResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getEstGetTimeResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstGetTimeResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getEstGetTimeResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getEstGetTimeResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__getEstGetTimeResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getEstGetTimeResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstGetTimeResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__getEstGetTimeResponse, sizeof(tns__getEstGetTimeResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__getEstGetTimeResponse * SOAP_FMAC2 soap_instantiate_tns__getEstGetTimeResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getEstGetTimeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__getEstGetTimeResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getEstGetTimeResponse;
	}
	else
	{	cp->ptr = (void*)new tns__getEstGetTimeResponse[n];
	}
	return (tns__getEstGetTimeResponse*)cp->ptr;
}

void tns__copyResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__copyResponse))
		this->soap_mark(soap);
}

void tns__copyResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__copyResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__copyResponse*)this)->_Result);
}

void tns__copyResponse::soap_default(struct soap *soap)
{
	static tns__copyResponse a;
	memcpy(this, &a, sizeof(tns__copyResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__copyResponse*)this)->_Result);
}

int tns__copyResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__copyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__copyResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__copyResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__copyResponse(struct soap *soap, const char *tag, int id, const tns__copyResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__copyResponse), "tns:copyResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__copyResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__copyResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__copyResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__copyResponse * SOAP_FMAC2 soap_get_tns__copyResponse(struct soap *soap, tns__copyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__copyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__copyResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__copyResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__copyResponse * SOAP_FMAC2 soap_in_tns__copyResponse(struct soap *soap, const char *tag, tns__copyResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__copyResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__copyResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__copyResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__copyResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__copyResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__copyResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__copyResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__copyResponse, sizeof(tns__copyResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__copyResponse * SOAP_FMAC2 soap_instantiate_tns__copyResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__copyResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__copyResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__copyResponse;
	}
	else
	{	cp->ptr = (void*)new tns__copyResponse[n];
	}
	return (tns__copyResponse*)cp->ptr;
}

void tns__mkPermanentResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__mkPermanentResponse))
		this->soap_mark(soap);
}

void tns__mkPermanentResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__mkPermanentResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__mkPermanentResponse*)this)->_Result);
}

void tns__mkPermanentResponse::soap_default(struct soap *soap)
{
	static tns__mkPermanentResponse a;
	memcpy(this, &a, sizeof(tns__mkPermanentResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__mkPermanentResponse*)this)->_Result);
}

int tns__mkPermanentResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__mkPermanentResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__mkPermanentResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__mkPermanentResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__mkPermanentResponse(struct soap *soap, const char *tag, int id, const tns__mkPermanentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__mkPermanentResponse), "tns:mkPermanentResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__mkPermanentResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__mkPermanentResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__mkPermanentResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__mkPermanentResponse * SOAP_FMAC2 soap_get_tns__mkPermanentResponse(struct soap *soap, tns__mkPermanentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mkPermanentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__mkPermanentResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__mkPermanentResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__mkPermanentResponse * SOAP_FMAC2 soap_in_tns__mkPermanentResponse(struct soap *soap, const char *tag, tns__mkPermanentResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__mkPermanentResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__mkPermanentResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__mkPermanentResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__mkPermanentResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__mkPermanentResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__mkPermanentResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__mkPermanentResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__mkPermanentResponse, sizeof(tns__mkPermanentResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__mkPermanentResponse * SOAP_FMAC2 soap_instantiate_tns__mkPermanentResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__mkPermanentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__mkPermanentResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__mkPermanentResponse;
	}
	else
	{	cp->ptr = (void*)new tns__mkPermanentResponse[n];
	}
	return (tns__mkPermanentResponse*)cp->ptr;
}

void ns11__RequestFileStatus::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns11__RequestFileStatus))
		this->soap_mark(soap);
}

void ns11__RequestFileStatus::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->SURL, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->SURL);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->size, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->owner, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->owner);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->group, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->group);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->permMode, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->checksumType, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->checksumType);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->checksumValue, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->checksumValue);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->isPinned, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->isPermanent, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->isCached, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->state, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->state);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->fileId, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->TURL, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->TURL);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->estSecondsToStart, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->sourceFilename, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->sourceFilename);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->destFilename, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestFileStatus*)this)->destFilename);
	soap_embedded(soap, &((ns11__RequestFileStatus*)this)->queueOrder, SOAP_TYPE_xsd__int);
}

void ns11__RequestFileStatus::soap_default(struct soap *soap)
{
	static ns11__RequestFileStatus a;
	memcpy(this, &a, sizeof(ns11__RequestFileStatus));
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->SURL);
	soap_default_xsd__long(soap, &((ns11__RequestFileStatus*)this)->size);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->owner);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->group);
	soap_default_xsd__int(soap, &((ns11__RequestFileStatus*)this)->permMode);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->checksumType);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->checksumValue);
	soap_default_xsd__boolean(soap, &((ns11__RequestFileStatus*)this)->isPinned);
	soap_default_xsd__boolean(soap, &((ns11__RequestFileStatus*)this)->isPermanent);
	soap_default_xsd__boolean(soap, &((ns11__RequestFileStatus*)this)->isCached);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->state);
	soap_default_xsd__int(soap, &((ns11__RequestFileStatus*)this)->fileId);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->TURL);
	soap_default_xsd__int(soap, &((ns11__RequestFileStatus*)this)->estSecondsToStart);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->sourceFilename);
	soap_default_xsd__string(soap, &((ns11__RequestFileStatus*)this)->destFilename);
	soap_default_xsd__int(soap, &((ns11__RequestFileStatus*)this)->queueOrder);
}

int ns11__RequestFileStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_ns11__RequestFileStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ns11__RequestFileStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns11__RequestFileStatus(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ns11__RequestFileStatus(struct soap *soap, const char *tag, int id, const ns11__RequestFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns11__RequestFileStatus), "ns11:RequestFileStatus");
	soap_out_xsd__string(soap, "SURL", -1, &(((ns11__RequestFileStatus*)a)->SURL), "xsd:string");
	soap_out_xsd__long(soap, "size", -1, &(((ns11__RequestFileStatus*)a)->size), "xsd:long");
	soap_out_xsd__string(soap, "owner", -1, &(((ns11__RequestFileStatus*)a)->owner), "xsd:string");
	soap_out_xsd__string(soap, "group", -1, &(((ns11__RequestFileStatus*)a)->group), "xsd:string");
	soap_out_xsd__int(soap, "permMode", -1, &(((ns11__RequestFileStatus*)a)->permMode), "xsd:int");
	soap_out_xsd__string(soap, "checksumType", -1, &(((ns11__RequestFileStatus*)a)->checksumType), "xsd:string");
	soap_out_xsd__string(soap, "checksumValue", -1, &(((ns11__RequestFileStatus*)a)->checksumValue), "xsd:string");
	soap_out_xsd__boolean(soap, "isPinned", -1, &(((ns11__RequestFileStatus*)a)->isPinned), "xsd:boolean");
	soap_out_xsd__boolean(soap, "isPermanent", -1, &(((ns11__RequestFileStatus*)a)->isPermanent), "xsd:boolean");
	soap_out_xsd__boolean(soap, "isCached", -1, &(((ns11__RequestFileStatus*)a)->isCached), "xsd:boolean");
	soap_out_xsd__string(soap, "state", -1, &(((ns11__RequestFileStatus*)a)->state), "xsd:string");
	soap_out_xsd__int(soap, "fileId", -1, &(((ns11__RequestFileStatus*)a)->fileId), "xsd:int");
	soap_out_xsd__string(soap, "TURL", -1, &(((ns11__RequestFileStatus*)a)->TURL), "xsd:string");
	soap_out_xsd__int(soap, "estSecondsToStart", -1, &(((ns11__RequestFileStatus*)a)->estSecondsToStart), "xsd:int");
	soap_out_xsd__string(soap, "sourceFilename", -1, &(((ns11__RequestFileStatus*)a)->sourceFilename), "xsd:string");
	soap_out_xsd__string(soap, "destFilename", -1, &(((ns11__RequestFileStatus*)a)->destFilename), "xsd:string");
	soap_out_xsd__int(soap, "queueOrder", -1, &(((ns11__RequestFileStatus*)a)->queueOrder), "xsd:int");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns11__RequestFileStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns11__RequestFileStatus(soap, this, tag, type);
}

SOAP_FMAC1 ns11__RequestFileStatus * SOAP_FMAC2 soap_get_ns11__RequestFileStatus(struct soap *soap, ns11__RequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns11__RequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns11__RequestFileStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns11__RequestFileStatus(soap, tag, this, type);
}

SOAP_FMAC1 ns11__RequestFileStatus * SOAP_FMAC2 soap_in_ns11__RequestFileStatus(struct soap *soap, const char *tag, ns11__RequestFileStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns11__RequestFileStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__RequestFileStatus, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns11__RequestFileStatus)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns11__RequestFileStatus *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_SURL1 = 1, soap_flag_size1 = 1, soap_flag_owner1 = 1, soap_flag_group1 = 1, soap_flag_permMode1 = 1, soap_flag_checksumType1 = 1, soap_flag_checksumValue1 = 1, soap_flag_isPinned1 = 1, soap_flag_isPermanent1 = 1, soap_flag_isCached1 = 1, soap_flag_state1 = 1, soap_flag_fileId1 = 1, soap_flag_TURL1 = 1, soap_flag_estSecondsToStart1 = 1, soap_flag_sourceFilename1 = 1, soap_flag_destFilename1 = 1, soap_flag_queueOrder1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_SURL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "SURL", &(((ns11__RequestFileStatus*)a)->SURL), "xsd:string"))
				{	soap_flag_SURL1 = 0;
					continue;
				}

			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__long(soap, "size", &(((ns11__RequestFileStatus*)a)->size), "xsd:long"))
				{	soap_flag_size1 = 0;
					continue;
				}

			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "owner", &(((ns11__RequestFileStatus*)a)->owner), "xsd:string"))
				{	soap_flag_owner1 = 0;
					continue;
				}

			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "group", &(((ns11__RequestFileStatus*)a)->group), "xsd:string"))
				{	soap_flag_group1 = 0;
					continue;
				}

			if (soap_flag_permMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "permMode", &(((ns11__RequestFileStatus*)a)->permMode), "xsd:int"))
				{	soap_flag_permMode1 = 0;
					continue;
				}

			if (soap_flag_checksumType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "checksumType", &(((ns11__RequestFileStatus*)a)->checksumType), "xsd:string"))
				{	soap_flag_checksumType1 = 0;
					continue;
				}

			if (soap_flag_checksumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "checksumValue", &(((ns11__RequestFileStatus*)a)->checksumValue), "xsd:string"))
				{	soap_flag_checksumValue1 = 0;
					continue;
				}

			if (soap_flag_isPinned1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isPinned", &(((ns11__RequestFileStatus*)a)->isPinned), "xsd:boolean"))
				{	soap_flag_isPinned1 = 0;
					continue;
				}

			if (soap_flag_isPermanent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isPermanent", &(((ns11__RequestFileStatus*)a)->isPermanent), "xsd:boolean"))
				{	soap_flag_isPermanent1 = 0;
					continue;
				}

			if (soap_flag_isCached1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isCached", &(((ns11__RequestFileStatus*)a)->isCached), "xsd:boolean"))
				{	soap_flag_isCached1 = 0;
					continue;
				}

			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "state", &(((ns11__RequestFileStatus*)a)->state), "xsd:string"))
				{	soap_flag_state1 = 0;
					continue;
				}

			if (soap_flag_fileId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "fileId", &(((ns11__RequestFileStatus*)a)->fileId), "xsd:int"))
				{	soap_flag_fileId1 = 0;
					continue;
				}

			if (soap_flag_TURL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "TURL", &(((ns11__RequestFileStatus*)a)->TURL), "xsd:string"))
				{	soap_flag_TURL1 = 0;
					continue;
				}

			if (soap_flag_estSecondsToStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "estSecondsToStart", &(((ns11__RequestFileStatus*)a)->estSecondsToStart), "xsd:int"))
				{	soap_flag_estSecondsToStart1 = 0;
					continue;
				}

			if (soap_flag_sourceFilename1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "sourceFilename", &(((ns11__RequestFileStatus*)a)->sourceFilename), "xsd:string"))
				{	soap_flag_sourceFilename1 = 0;
					continue;
				}

			if (soap_flag_destFilename1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "destFilename", &(((ns11__RequestFileStatus*)a)->destFilename), "xsd:string"))
				{	soap_flag_destFilename1 = 0;
					continue;
				}

			if (soap_flag_queueOrder1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "queueOrder", &(((ns11__RequestFileStatus*)a)->queueOrder), "xsd:int"))
				{	soap_flag_queueOrder1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns11__RequestFileStatus *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__RequestFileStatus, soap->type, soap->arrayType), SOAP_TYPE_ns11__RequestFileStatus, sizeof(ns11__RequestFileStatus));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns11__RequestFileStatus * SOAP_FMAC2 soap_instantiate_ns11__RequestFileStatus(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns11__RequestFileStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ns11__RequestFileStatus;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ns11__RequestFileStatus;
	}
	else
	{	cp->ptr = (void*)new ns11__RequestFileStatus[n];
	}
	return (ns11__RequestFileStatus*)cp->ptr;
}

void tns__putResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__putResponse))
		this->soap_mark(soap);
}

void tns__putResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__putResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__putResponse*)this)->_Result);
}

void tns__putResponse::soap_default(struct soap *soap)
{
	static tns__putResponse a;
	memcpy(this, &a, sizeof(tns__putResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__putResponse*)this)->_Result);
}

int tns__putResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__putResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__putResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__putResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__putResponse(struct soap *soap, const char *tag, int id, const tns__putResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__putResponse), "tns:putResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__putResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__putResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__putResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__putResponse * SOAP_FMAC2 soap_get_tns__putResponse(struct soap *soap, tns__putResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__putResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__putResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__putResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__putResponse * SOAP_FMAC2 soap_in_tns__putResponse(struct soap *soap, const char *tag, tns__putResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__putResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__putResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__putResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__putResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__putResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__putResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__putResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__putResponse, sizeof(tns__putResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__putResponse * SOAP_FMAC2 soap_instantiate_tns__putResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__putResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__putResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__putResponse;
	}
	else
	{	cp->ptr = (void*)new tns__putResponse[n];
	}
	return (tns__putResponse*)cp->ptr;
}

void ArrayOflong::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOflong::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOflong))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_xsd__long);
		}
}

void ArrayOflong::soap_default(struct soap *soap)
{
	static ArrayOflong a;
	memcpy(this, &a, sizeof(ArrayOflong));
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOflong::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOflong, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ArrayOflong::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOflong(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ArrayOflong(struct soap *soap, const char *tag, int id, const ArrayOflong *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "xsd:long", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOflong, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		soap_out_xsd__long(soap, "item", 0, &a->__ptr[i], "xsd:long");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOflong::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOflong(soap, this, tag, type);
}

SOAP_FMAC1 ArrayOflong * SOAP_FMAC2 soap_get_ArrayOflong(struct soap *soap, ArrayOflong *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOflong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOflong::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOflong(soap, tag, this, type);
}

SOAP_FMAC1 ArrayOflong * SOAP_FMAC2 soap_in_ArrayOflong(struct soap *soap, const char *tag, ArrayOflong *a, const char *type)
{	int i, j;
	LONG64 *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOflong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOflong, soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOflong *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOflong, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = (LONG64 *)soap_malloc(soap, sizeof(LONG64) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_xsd__long(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_xsd__long(soap, NULL, a->__ptr+i, "xsd:long"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (LONG64 *)soap_push_block(soap, sizeof(LONG64));
				if (!p)
					return NULL;
				soap_default_xsd__long(soap, p);
				if (!soap_in_xsd__long(soap, NULL, p, "xsd:long"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (LONG64 *)soap_malloc(soap, soap->blist->size);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOflong *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOflong, soap->type, soap->arrayType), SOAP_TYPE_ArrayOflong, sizeof(ArrayOflong));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 ArrayOflong * SOAP_FMAC2 soap_instantiate_ArrayOflong(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOflong(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ArrayOflong;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOflong;
	}
	else
	{	cp->ptr = (void*)new ArrayOflong[n];
	}
	return (ArrayOflong*)cp->ptr;
}

void ArrayOfstring::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfstring::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfstring))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_xsd__string);
			soap_mark_xsd__string(soap, this->__ptr + i);
		}
}

void ArrayOfstring::soap_default(struct soap *soap)
{
	static ArrayOfstring a;
	memcpy(this, &a, sizeof(ArrayOfstring));
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfstring::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfstring, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ArrayOfstring::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfstring(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ArrayOfstring(struct soap *soap, const char *tag, int id, const ArrayOfstring *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "xsd:string", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfstring, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_xsd__string(soap, "item", 0, &a->__ptr[i], "xsd:string");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfstring::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfstring(soap, this, tag, type);
}

SOAP_FMAC1 ArrayOfstring * SOAP_FMAC2 soap_get_ArrayOfstring(struct soap *soap, ArrayOfstring *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfstring::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfstring(soap, tag, this, type);
}

SOAP_FMAC1 ArrayOfstring * SOAP_FMAC2 soap_in_ArrayOfstring(struct soap *soap, const char *tag, ArrayOfstring *a, const char *type)
{	int i, j;
	char **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfstring, soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfstring *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfstring, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = (char **)soap_malloc(soap, sizeof(char *) * a->__size);
			for (i = 0; i < a->__size; i++)
				soap_default_xsd__string(soap, a->__ptr+i);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_xsd__string(soap, NULL, a->__ptr+i, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (char **)soap_push_block(soap, sizeof(char *));
				if (!p)
					return NULL;
				soap_default_xsd__string(soap, p);
				if (!soap_in_xsd__string(soap, NULL, p, "xsd:string"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (char **)soap_malloc(soap, soap->blist->size);
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfstring *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfstring, soap->type, soap->arrayType), SOAP_TYPE_ArrayOfstring, sizeof(ArrayOfstring));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 ArrayOfstring * SOAP_FMAC2 soap_instantiate_ArrayOfstring(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfstring(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ArrayOfstring;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfstring;
	}
	else
	{	cp->ptr = (void*)new ArrayOfstring[n];
	}
	return (ArrayOfstring*)cp->ptr;
}

void ns11__FileMetaData::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns11__FileMetaData))
		this->soap_mark(soap);
}

void ns11__FileMetaData::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns11__FileMetaData*)this)->SURL, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__FileMetaData*)this)->SURL);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->size, SOAP_TYPE_xsd__long);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->owner, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__FileMetaData*)this)->owner);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->group, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__FileMetaData*)this)->group);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->permMode, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->checksumType, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__FileMetaData*)this)->checksumType);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->checksumValue, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__FileMetaData*)this)->checksumValue);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->isPinned, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->isPermanent, SOAP_TYPE_xsd__boolean);
	soap_embedded(soap, &((ns11__FileMetaData*)this)->isCached, SOAP_TYPE_xsd__boolean);
}

void ns11__FileMetaData::soap_default(struct soap *soap)
{
	static ns11__FileMetaData a;
	memcpy(this, &a, sizeof(ns11__FileMetaData));
	soap_default_xsd__string(soap, &((ns11__FileMetaData*)this)->SURL);
	soap_default_xsd__long(soap, &((ns11__FileMetaData*)this)->size);
	soap_default_xsd__string(soap, &((ns11__FileMetaData*)this)->owner);
	soap_default_xsd__string(soap, &((ns11__FileMetaData*)this)->group);
	soap_default_xsd__int(soap, &((ns11__FileMetaData*)this)->permMode);
	soap_default_xsd__string(soap, &((ns11__FileMetaData*)this)->checksumType);
	soap_default_xsd__string(soap, &((ns11__FileMetaData*)this)->checksumValue);
	soap_default_xsd__boolean(soap, &((ns11__FileMetaData*)this)->isPinned);
	soap_default_xsd__boolean(soap, &((ns11__FileMetaData*)this)->isPermanent);
	soap_default_xsd__boolean(soap, &((ns11__FileMetaData*)this)->isCached);
}

int ns11__FileMetaData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_ns11__FileMetaData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ns11__FileMetaData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns11__FileMetaData(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ns11__FileMetaData(struct soap *soap, const char *tag, int id, const ns11__FileMetaData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns11__FileMetaData), "ns11:FileMetaData");
	soap_out_xsd__string(soap, "SURL", -1, &(((ns11__FileMetaData*)a)->SURL), "xsd:string");
	soap_out_xsd__long(soap, "size", -1, &(((ns11__FileMetaData*)a)->size), "xsd:long");
	soap_out_xsd__string(soap, "owner", -1, &(((ns11__FileMetaData*)a)->owner), "xsd:string");
	soap_out_xsd__string(soap, "group", -1, &(((ns11__FileMetaData*)a)->group), "xsd:string");
	soap_out_xsd__int(soap, "permMode", -1, &(((ns11__FileMetaData*)a)->permMode), "xsd:int");
	soap_out_xsd__string(soap, "checksumType", -1, &(((ns11__FileMetaData*)a)->checksumType), "xsd:string");
	soap_out_xsd__string(soap, "checksumValue", -1, &(((ns11__FileMetaData*)a)->checksumValue), "xsd:string");
	soap_out_xsd__boolean(soap, "isPinned", -1, &(((ns11__FileMetaData*)a)->isPinned), "xsd:boolean");
	soap_out_xsd__boolean(soap, "isPermanent", -1, &(((ns11__FileMetaData*)a)->isPermanent), "xsd:boolean");
	soap_out_xsd__boolean(soap, "isCached", -1, &(((ns11__FileMetaData*)a)->isCached), "xsd:boolean");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns11__FileMetaData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns11__FileMetaData(soap, this, tag, type);
}

SOAP_FMAC1 ns11__FileMetaData * SOAP_FMAC2 soap_get_ns11__FileMetaData(struct soap *soap, ns11__FileMetaData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns11__FileMetaData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns11__FileMetaData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns11__FileMetaData(soap, tag, this, type);
}

SOAP_FMAC1 ns11__FileMetaData * SOAP_FMAC2 soap_in_ns11__FileMetaData(struct soap *soap, const char *tag, ns11__FileMetaData *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns11__FileMetaData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__FileMetaData, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns11__FileMetaData)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns11__FileMetaData *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_SURL1 = 1, soap_flag_size1 = 1, soap_flag_owner1 = 1, soap_flag_group1 = 1, soap_flag_permMode1 = 1, soap_flag_checksumType1 = 1, soap_flag_checksumValue1 = 1, soap_flag_isPinned1 = 1, soap_flag_isPermanent1 = 1, soap_flag_isCached1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_SURL1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "SURL", &(((ns11__FileMetaData*)a)->SURL), "xsd:string"))
				{	soap_flag_SURL1 = 0;
					continue;
				}

			if (soap_flag_size1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__long(soap, "size", &(((ns11__FileMetaData*)a)->size), "xsd:long"))
				{	soap_flag_size1 = 0;
					continue;
				}

			if (soap_flag_owner1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "owner", &(((ns11__FileMetaData*)a)->owner), "xsd:string"))
				{	soap_flag_owner1 = 0;
					continue;
				}

			if (soap_flag_group1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "group", &(((ns11__FileMetaData*)a)->group), "xsd:string"))
				{	soap_flag_group1 = 0;
					continue;
				}

			if (soap_flag_permMode1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "permMode", &(((ns11__FileMetaData*)a)->permMode), "xsd:int"))
				{	soap_flag_permMode1 = 0;
					continue;
				}

			if (soap_flag_checksumType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "checksumType", &(((ns11__FileMetaData*)a)->checksumType), "xsd:string"))
				{	soap_flag_checksumType1 = 0;
					continue;
				}

			if (soap_flag_checksumValue1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "checksumValue", &(((ns11__FileMetaData*)a)->checksumValue), "xsd:string"))
				{	soap_flag_checksumValue1 = 0;
					continue;
				}

			if (soap_flag_isPinned1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isPinned", &(((ns11__FileMetaData*)a)->isPinned), "xsd:boolean"))
				{	soap_flag_isPinned1 = 0;
					continue;
				}

			if (soap_flag_isPermanent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isPermanent", &(((ns11__FileMetaData*)a)->isPermanent), "xsd:boolean"))
				{	soap_flag_isPermanent1 = 0;
					continue;
				}

			if (soap_flag_isCached1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__boolean(soap, "isCached", &(((ns11__FileMetaData*)a)->isCached), "xsd:boolean"))
				{	soap_flag_isCached1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns11__FileMetaData *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__FileMetaData, soap->type, soap->arrayType), SOAP_TYPE_ns11__FileMetaData, sizeof(ns11__FileMetaData));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns11__FileMetaData * SOAP_FMAC2 soap_instantiate_ns11__FileMetaData(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns11__FileMetaData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ns11__FileMetaData;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ns11__FileMetaData;
	}
	else
	{	cp->ptr = (void*)new ns11__FileMetaData[n];
	}
	return (ns11__FileMetaData*)cp->ptr;
}

void ArrayOfFileMetaData::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfFileMetaData::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfFileMetaData))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns11__FileMetaData);
			this->__ptr[i].soap_mark(soap);
		}
}

void ArrayOfFileMetaData::soap_default(struct soap *soap)
{
	static ArrayOfFileMetaData a;
	memcpy(this, &a, sizeof(ArrayOfFileMetaData));
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfFileMetaData::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfFileMetaData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ArrayOfFileMetaData::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfFileMetaData(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ArrayOfFileMetaData(struct soap *soap, const char *tag, int id, const ArrayOfFileMetaData *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "ns11:FileMetaData", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfFileMetaData, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, "ns11:FileMetaData");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfFileMetaData::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfFileMetaData(soap, this, tag, type);
}

SOAP_FMAC1 ArrayOfFileMetaData * SOAP_FMAC2 soap_get_ArrayOfFileMetaData(struct soap *soap, ArrayOfFileMetaData *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfFileMetaData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfFileMetaData::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfFileMetaData(soap, tag, this, type);
}

SOAP_FMAC1 ArrayOfFileMetaData * SOAP_FMAC2 soap_in_ArrayOfFileMetaData(struct soap *soap, const char *tag, ArrayOfFileMetaData *a, const char *type)
{	int i, j;
	ns11__FileMetaData *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfFileMetaData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfFileMetaData, soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfFileMetaData *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfFileMetaData, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = soap_instantiate_ns11__FileMetaData(soap, a->__size, NULL, NULL);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->ns11__FileMetaData::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_ns11__FileMetaData(soap, NULL, a->__ptr+i, "ns11:FileMetaData"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns11__FileMetaData *)soap_push_block(soap, sizeof(ns11__FileMetaData));
				if (!p)
					return NULL;
				p->ns11__FileMetaData::soap_default(soap);
				if (!soap_in_ns11__FileMetaData(soap, NULL, p, "ns11:FileMetaData"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_instantiate_ns11__FileMetaData(soap, soap->blist->size/sizeof(ns11__FileMetaData), NULL, NULL);
			else
				a->__ptr = NULL;
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfFileMetaData *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfFileMetaData, soap->type, soap->arrayType), SOAP_TYPE_ArrayOfFileMetaData, sizeof(ArrayOfFileMetaData));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 ArrayOfFileMetaData * SOAP_FMAC2 soap_instantiate_ArrayOfFileMetaData(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfFileMetaData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ArrayOfFileMetaData;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfFileMetaData;
	}
	else
	{	cp->ptr = (void*)new ArrayOfFileMetaData[n];
	}
	return (ArrayOfFileMetaData*)cp->ptr;
}

void ArrayOfRequestFileStatus::soap_serialize(struct soap *soap) const
{
	this->soap_mark(soap);
}

void ArrayOfRequestFileStatus::soap_mark(struct soap *soap) const
{
	int i;
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfRequestFileStatus))
		for (i = 0; i < this->__size; i++)
		{	soap_embedded(soap, this->__ptr + i, SOAP_TYPE_ns11__RequestFileStatus);
			this->__ptr[i].soap_mark(soap);
		}
}

void ArrayOfRequestFileStatus::soap_default(struct soap *soap)
{
	static ArrayOfRequestFileStatus a;
	memcpy(this, &a, sizeof(ArrayOfRequestFileStatus));
	this->__size = 0;
	this->__ptr = NULL;
	this->__offset = 0;
}

int ArrayOfRequestFileStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_array_pointer_lookup(soap, this, (struct soap_array*)&this->__ptr, this->__size, SOAP_TYPE_ArrayOfRequestFileStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ArrayOfRequestFileStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfRequestFileStatus(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ArrayOfRequestFileStatus(struct soap *soap, const char *tag, int id, const ArrayOfRequestFileStatus *a, const char *type)
{
	int i;
	struct soap_plist *pp;
	int n = a->__size;
	char *t = soap_putsize(soap, "ns11:RequestFileStatus", n + a->__offset);
	i = soap_array_pointer_lookup(soap, a, (struct soap_array*)&a->__ptr, n, SOAP_TYPE_ArrayOfRequestFileStatus, &pp);
	if (!a->__ptr)
	{	soap_element_null(soap, tag, i, t);
		return SOAP_OK;
	}
	if (id <= 0 && i)
	{	if (soap_is_embedded(soap, pp))
		{	soap_element_ref(soap, tag, 0, i);
			return SOAP_OK;
		}
		if (soap_is_single(soap, pp))
			i = 0;
	}
	else if (id > 0)
		i = id;
	soap_array_begin_out(soap, tag, i, t, soap_putoffset(soap, a->__offset));
	if (i)
		soap_set_embedded(soap, pp);
	for (i = 0; i < n; i++)
	{
		a->__ptr[i].soap_out(soap, "item", -1, "ns11:RequestFileStatus");
	}
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfRequestFileStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfRequestFileStatus(soap, this, tag, type);
}

SOAP_FMAC1 ArrayOfRequestFileStatus * SOAP_FMAC2 soap_get_ArrayOfRequestFileStatus(struct soap *soap, ArrayOfRequestFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfRequestFileStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfRequestFileStatus(soap, tag, this, type);
}

SOAP_FMAC1 ArrayOfRequestFileStatus * SOAP_FMAC2 soap_in_ArrayOfRequestFileStatus(struct soap *soap, const char *tag, ArrayOfRequestFileStatus *a, const char *type)
{	int i, j;
	ns11__RequestFileStatus *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if ((a = (ArrayOfRequestFileStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRequestFileStatus, soap->type, soap->arrayType)))
			a->soap_default(soap);
			if (soap->body && soap_element_end_in(soap, tag))
				return NULL;
	}
	else if (!*soap->href)
	{	if (!(a = (ArrayOfRequestFileStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRequestFileStatus, soap->type, soap->arrayType)))
			return NULL;
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body)
		{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		a->__offset = j;
		if (j >= 0 && a->__size >= 0)
		{	a->__ptr = soap_instantiate_ns11__RequestFileStatus(soap, a->__size, NULL, NULL);
			for (i = 0; i < a->__size; i++)
				(a->__ptr+i)->ns11__RequestFileStatus::soap_default(soap);
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
					return NULL;
					}
				}
				if (!soap_in_ns11__RequestFileStatus(soap, NULL, a->__ptr+i, "ns11:RequestFileStatus"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns11__RequestFileStatus *)soap_push_block(soap, sizeof(ns11__RequestFileStatus));
				if (!p)
					return NULL;
				p->ns11__RequestFileStatus::soap_default(soap);
				if (!soap_in_ns11__RequestFileStatus(soap, NULL, p, "ns11:RequestFileStatus"))
				{	if (soap->error == SOAP_NO_TAG)
					{	soap->error = SOAP_OK;
						break;
					}
					else
						return NULL;
				}
			}
			soap_pop_block(soap);
			if (soap->blist->size)
				a->__ptr = soap_instantiate_ns11__RequestFileStatus(soap, soap->blist->size/sizeof(ns11__RequestFileStatus), NULL, NULL);
			else
				a->__ptr = NULL;
			soap_store_block(soap, (char*)a->__ptr);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ArrayOfRequestFileStatus *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRequestFileStatus, soap->type, soap->arrayType), SOAP_TYPE_ArrayOfRequestFileStatus, sizeof(ArrayOfRequestFileStatus));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	}
	return a;
}

SOAP_FMAC1 ArrayOfRequestFileStatus * SOAP_FMAC2 soap_instantiate_ArrayOfRequestFileStatus(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfRequestFileStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ArrayOfRequestFileStatus;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfRequestFileStatus;
	}
	else
	{	cp->ptr = (void*)new ArrayOfRequestFileStatus[n];
	}
	return (ArrayOfRequestFileStatus*)cp->ptr;
}

void tns__advisoryDeleteResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__advisoryDeleteResponse))
		this->soap_mark(soap);
}

void tns__advisoryDeleteResponse::soap_mark(struct soap *soap) const
{
}

void tns__advisoryDeleteResponse::soap_default(struct soap *soap)
{
	static tns__advisoryDeleteResponse a;
	memcpy(this, &a, sizeof(tns__advisoryDeleteResponse));
}

int tns__advisoryDeleteResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__advisoryDeleteResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__advisoryDeleteResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__advisoryDeleteResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__advisoryDeleteResponse(struct soap *soap, const char *tag, int id, const tns__advisoryDeleteResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__advisoryDeleteResponse), "tns:advisoryDeleteResponse");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__advisoryDeleteResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__advisoryDeleteResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__advisoryDeleteResponse * SOAP_FMAC2 soap_get_tns__advisoryDeleteResponse(struct soap *soap, tns__advisoryDeleteResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__advisoryDeleteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__advisoryDeleteResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__advisoryDeleteResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__advisoryDeleteResponse * SOAP_FMAC2 soap_in_tns__advisoryDeleteResponse(struct soap *soap, const char *tag, tns__advisoryDeleteResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__advisoryDeleteResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__advisoryDeleteResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__advisoryDeleteResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__advisoryDeleteResponse *)a->soap_in(soap, tag, type);
			}
		};
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__advisoryDeleteResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__advisoryDeleteResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__advisoryDeleteResponse, sizeof(tns__advisoryDeleteResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__advisoryDeleteResponse * SOAP_FMAC2 soap_instantiate_tns__advisoryDeleteResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__advisoryDeleteResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__advisoryDeleteResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__advisoryDeleteResponse;
	}
	else
	{	cp->ptr = (void*)new tns__advisoryDeleteResponse[n];
	}
	return (tns__advisoryDeleteResponse*)cp->ptr;
}

void ns11__RequestStatus::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_ns11__RequestStatus))
		this->soap_mark(soap);
}

void ns11__RequestStatus::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((ns11__RequestStatus*)this)->requestId, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->type, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestStatus*)this)->type);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->state, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestStatus*)this)->state);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->submitTime, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((ns11__RequestStatus*)this)->submitTime);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->startTime, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((ns11__RequestStatus*)this)->startTime);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->finishTime, SOAP_TYPE_xsd__dateTime);
	soap_mark_xsd__dateTime(soap, &((ns11__RequestStatus*)this)->finishTime);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->estTimeToStart, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->fileStatuses, SOAP_TYPE_PointerToArrayOfRequestFileStatus);
	soap_mark_PointerToArrayOfRequestFileStatus(soap, &((ns11__RequestStatus*)this)->fileStatuses);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->errorMessage, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &((ns11__RequestStatus*)this)->errorMessage);
	soap_embedded(soap, &((ns11__RequestStatus*)this)->retryDeltaTime, SOAP_TYPE_xsd__int);
}

void ns11__RequestStatus::soap_default(struct soap *soap)
{
	static ns11__RequestStatus a;
	memcpy(this, &a, sizeof(ns11__RequestStatus));
	soap_default_xsd__int(soap, &((ns11__RequestStatus*)this)->requestId);
	soap_default_xsd__string(soap, &((ns11__RequestStatus*)this)->type);
	soap_default_xsd__string(soap, &((ns11__RequestStatus*)this)->state);
	soap_default_xsd__dateTime(soap, &((ns11__RequestStatus*)this)->submitTime);
	soap_default_xsd__dateTime(soap, &((ns11__RequestStatus*)this)->startTime);
	soap_default_xsd__dateTime(soap, &((ns11__RequestStatus*)this)->finishTime);
	soap_default_xsd__int(soap, &((ns11__RequestStatus*)this)->estTimeToStart);
	soap_default_PointerToArrayOfRequestFileStatus(soap, &((ns11__RequestStatus*)this)->fileStatuses);
	soap_default_xsd__string(soap, &((ns11__RequestStatus*)this)->errorMessage);
	soap_default_xsd__int(soap, &((ns11__RequestStatus*)this)->retryDeltaTime);
}

int ns11__RequestStatus::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_ns11__RequestStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int ns11__RequestStatus::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns11__RequestStatus(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_ns11__RequestStatus(struct soap *soap, const char *tag, int id, const ns11__RequestStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns11__RequestStatus), "ns11:RequestStatus");
	soap_out_xsd__int(soap, "requestId", -1, &(((ns11__RequestStatus*)a)->requestId), "xsd:int");
	soap_out_xsd__string(soap, "type", -1, &(((ns11__RequestStatus*)a)->type), "xsd:string");
	soap_out_xsd__string(soap, "state", -1, &(((ns11__RequestStatus*)a)->state), "xsd:string");
	soap_out_xsd__dateTime(soap, "submitTime", -1, &(((ns11__RequestStatus*)a)->submitTime), "xsd:dateTime");
	soap_out_xsd__dateTime(soap, "startTime", -1, &(((ns11__RequestStatus*)a)->startTime), "xsd:dateTime");
	soap_out_xsd__dateTime(soap, "finishTime", -1, &(((ns11__RequestStatus*)a)->finishTime), "xsd:dateTime");
	soap_out_xsd__int(soap, "estTimeToStart", -1, &(((ns11__RequestStatus*)a)->estTimeToStart), "xsd:int");
	soap_out_PointerToArrayOfRequestFileStatus(soap, "fileStatuses", -1, &(((ns11__RequestStatus*)a)->fileStatuses), "ns11:RequestFileStatus");
	soap_out_xsd__string(soap, "errorMessage", -1, &(((ns11__RequestStatus*)a)->errorMessage), "xsd:string");
	soap_out_xsd__int(soap, "retryDeltaTime", -1, &(((ns11__RequestStatus*)a)->retryDeltaTime), "xsd:int");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns11__RequestStatus::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns11__RequestStatus(soap, this, tag, type);
}

SOAP_FMAC1 ns11__RequestStatus * SOAP_FMAC2 soap_get_ns11__RequestStatus(struct soap *soap, ns11__RequestStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns11__RequestStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns11__RequestStatus::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns11__RequestStatus(soap, tag, this, type);
}

SOAP_FMAC1 ns11__RequestStatus * SOAP_FMAC2 soap_in_ns11__RequestStatus(struct soap *soap, const char *tag, ns11__RequestStatus *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (ns11__RequestStatus *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__RequestStatus, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_ns11__RequestStatus)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (ns11__RequestStatus *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag_requestId1 = 1, soap_flag_type1 = 1, soap_flag_state1 = 1, soap_flag_submitTime1 = 1, soap_flag_startTime1 = 1, soap_flag_finishTime1 = 1, soap_flag_estTimeToStart1 = 1, soap_flag_fileStatuses1 = 1, soap_flag_errorMessage1 = 1, soap_flag_retryDeltaTime1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag_requestId1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "requestId", &(((ns11__RequestStatus*)a)->requestId), "xsd:int"))
				{	soap_flag_requestId1 = 0;
					continue;
				}

			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "type", &(((ns11__RequestStatus*)a)->type), "xsd:string"))
				{	soap_flag_type1 = 0;
					continue;
				}

			if (soap_flag_state1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "state", &(((ns11__RequestStatus*)a)->state), "xsd:string"))
				{	soap_flag_state1 = 0;
					continue;
				}

			if (soap_flag_submitTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "submitTime", &(((ns11__RequestStatus*)a)->submitTime), "xsd:dateTime"))
				{	soap_flag_submitTime1 = 0;
					continue;
				}

			if (soap_flag_startTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "startTime", &(((ns11__RequestStatus*)a)->startTime), "xsd:dateTime"))
				{	soap_flag_startTime1 = 0;
					continue;
				}

			if (soap_flag_finishTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__dateTime(soap, "finishTime", &(((ns11__RequestStatus*)a)->finishTime), "xsd:dateTime"))
				{	soap_flag_finishTime1 = 0;
					continue;
				}

			if (soap_flag_estTimeToStart1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "estTimeToStart", &(((ns11__RequestStatus*)a)->estTimeToStart), "xsd:int"))
				{	soap_flag_estTimeToStart1 = 0;
					continue;
				}

			if (soap_flag_fileStatuses1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRequestFileStatus(soap, "fileStatuses", &(((ns11__RequestStatus*)a)->fileStatuses), "ns11:RequestFileStatus"))
				{	soap_flag_fileStatuses1 = 0;
					continue;
				}

			if (soap_flag_errorMessage1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "errorMessage", &(((ns11__RequestStatus*)a)->errorMessage), "xsd:string"))
				{	soap_flag_errorMessage1 = 0;
					continue;
				}

			if (soap_flag_retryDeltaTime1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "retryDeltaTime", &(((ns11__RequestStatus*)a)->retryDeltaTime), "xsd:int"))
				{	soap_flag_retryDeltaTime1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (ns11__RequestStatus *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns11__RequestStatus, soap->type, soap->arrayType), SOAP_TYPE_ns11__RequestStatus, sizeof(ns11__RequestStatus));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 ns11__RequestStatus * SOAP_FMAC2 soap_instantiate_ns11__RequestStatus(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns11__RequestStatus(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_ns11__RequestStatus;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new ns11__RequestStatus;
	}
	else
	{	cp->ptr = (void*)new ns11__RequestStatus[n];
	}
	return (ns11__RequestStatus*)cp->ptr;
}

void tns__getResponse::soap_serialize(struct soap *soap) const
{
	if (!soap_reference(soap, this, SOAP_TYPE_tns__getResponse))
		this->soap_mark(soap);
}

void tns__getResponse::soap_mark(struct soap *soap) const
{
	soap_embedded(soap, &((tns__getResponse*)this)->_Result, SOAP_TYPE_PointerTons11__RequestStatus);
	soap_mark_PointerTons11__RequestStatus(soap, &((tns__getResponse*)this)->_Result);
}

void tns__getResponse::soap_default(struct soap *soap)
{
	static tns__getResponse a;
	memcpy(this, &a, sizeof(tns__getResponse));
	soap_default_PointerTons11__RequestStatus(soap, &((tns__getResponse*)this)->_Result);
}

int tns__getResponse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, this, SOAP_TYPE_tns__getResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			this->soap_out(soap, tag, 0, type);
		else
		{
			soap_set_embedded(soap, pp);
			this->soap_out(soap, tag, i, type);
		}
	else
		this->soap_out(soap, tag, 0, type);
	return soap_putindependent(soap);
}

int tns__getResponse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_tns__getResponse(soap, tag, id, this, type);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getResponse(struct soap *soap, const char *tag, int id, const tns__getResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getResponse), "tns:getResponse");
	soap_out_PointerTons11__RequestStatus(soap, "Result", -1, &(((tns__getResponse*)a)->_Result), "ns11:RequestStatus");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *tns__getResponse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_tns__getResponse(soap, this, tag, type);
}

SOAP_FMAC1 tns__getResponse * SOAP_FMAC2 soap_get_tns__getResponse(struct soap *soap, tns__getResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *tns__getResponse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_tns__getResponse(soap, tag, this, type);
}

SOAP_FMAC1 tns__getResponse * SOAP_FMAC2 soap_in_tns__getResponse(struct soap *soap, const char *tag, tns__getResponse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
		if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}	else
			return a;
	if (!*soap->href)
	{	if (!(a = (tns__getResponse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getResponse, soap->type, soap->arrayType)))
		{	soap->error = SOAP_TAG_MISMATCH;
			return NULL;
		}
		if (soap->alloced)
		{	a->soap_default(soap);
			if (soap->clist->type != SOAP_TYPE_tns__getResponse)
			{	soap_revert(soap);
				*soap->id = '\0';
				return (tns__getResponse *)a->soap_in(soap, tag, type);
			}
		}
		short soap_flag__Result1 = 1;
		if (soap->body)
		{	for (;;)
			{
			soap->error = SOAP_TAG_MISMATCH;

			if (soap_flag__Result1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons11__RequestStatus(soap, NULL, &(((tns__getResponse*)a)->_Result), "ns11:RequestStatus"))
				{	soap_flag__Result1 = 0;
					continue;
				}

			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (tns__getResponse *)soap_id_forward(soap, soap->href, (void**)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getResponse, soap->type, soap->arrayType), SOAP_TYPE_tns__getResponse, sizeof(tns__getResponse));
		if (soap->alloced)
			a->soap_default(soap);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 tns__getResponse * SOAP_FMAC2 soap_instantiate_tns__getResponse(struct soap *soap, int n, const char *type, const char *arrayType)
{
DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_tns__getResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	soap->alloced = 1;
	struct soap_clist *cp = (struct soap_clist*)malloc(sizeof(struct soap_clist));
	if (!cp)
		return NULL;
	cp->next = soap->clist;
	cp->type = SOAP_TYPE_tns__getResponse;
	cp->size = n; 
	soap->clist = cp;
	if (n < 0)
	{	cp->ptr = (void*)new tns__getResponse;
	}
	else
	{	cp->ptr = (void*)new tns__getResponse[n];
	}
	return (tns__getResponse*)cp->ptr;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Fault))
		soap_mark_SOAP_ENV__Fault(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	soap_embedded(soap, &a->faultcode, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultcode);
	soap_embedded(soap, &a->faultstring, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultstring);
	soap_embedded(soap, &a->faultactor, SOAP_TYPE_string);
	soap_mark_string(soap, &a->faultactor);
	soap_embedded(soap, &a->detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->detail);
	soap_embedded(soap, &a->SOAP_ENV__Code, SOAP_TYPE_PointerToSOAP_ENV__Code);
	soap_mark_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_embedded(soap, &a->SOAP_ENV__Reason, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Reason);
	soap_embedded(soap, &a->SOAP_ENV__Detail, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	soap_default_string(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	soap_default_string(soap, &a->detail);
	soap_default_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_default_string(soap, &a->SOAP_ENV__Reason);
	soap_default_string(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Fault, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Fault(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Fault(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out_string(soap, "faultcode", -1, &a->faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_string(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_string(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Fault * SOAP_FMAC2 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode = 0;
					continue;
				}
			if (soap_flag_faultstring && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultstring", &a->faultstring, ""))
				{	soap_flag_faultstring = 0;
					continue;
				}
			if (soap_flag_faultactor && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "faultactor", &a->faultactor, ""))
				{	soap_flag_faultactor = 0;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "detail", &a->detail, ""))
				{	soap_flag_detail = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0), SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault));
		if (soap->alloced)
			soap_default_SOAP_ENV__Fault(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	soap_embedded(soap, &a->SOAP_ENV__Value, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Value);
	soap_embedded(soap, &a->SOAP_ENV__Node, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Node);
	soap_embedded(soap, &a->SOAP_ENV__Role, SOAP_TYPE_string);
	soap_mark_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	soap_default_string(soap, &a->SOAP_ENV__Value);
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Code(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out_string(soap, "SOAP-ENV:Value", -1, &a->SOAP_ENV__Value, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code * SOAP_FMAC2 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, ""))
				{	soap_flag_SOAP_ENV__Node = 0;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, ""))
				{	soap_flag_SOAP_ENV__Role = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code));
		if (soap->alloced)
			soap_default_SOAP_ENV__Code(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_SOAP_ENV__Header))
		soap_mark_SOAP_ENV__Header(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	/* transient dummy skipped */
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_SOAP_ENV__Header, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_SOAP_ENV__Header(soap, tag, i, a, type);
		}
	else
		soap_out_SOAP_ENV__Header(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Header * SOAP_FMAC2 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0), SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header));
		if (soap->alloced)
			soap_default_SOAP_ENV__Header(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__getFileMetaData(struct soap *soap, struct tns__getFileMetaData const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getFileMetaData))
		soap_mark_tns__getFileMetaData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__getFileMetaData(struct soap *soap, const struct tns__getFileMetaData *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__getFileMetaData(struct soap *soap, struct tns__getFileMetaData *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__getFileMetaData(struct soap *soap, struct tns__getFileMetaData *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__getFileMetaData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__getFileMetaData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__getFileMetaData(soap, tag, i, a, type);
		}
	else
		soap_out_tns__getFileMetaData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getFileMetaData(struct soap *soap, const char *tag, int id, const struct tns__getFileMetaData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getFileMetaData), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__getFileMetaData * SOAP_FMAC2 soap_get_tns__getFileMetaData(struct soap *soap, struct tns__getFileMetaData *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getFileMetaData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__getFileMetaData * SOAP_FMAC2 soap_in_tns__getFileMetaData(struct soap *soap, const char *tag, struct tns__getFileMetaData *a, const char *type)
{
	short soap_flag_arg0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getFileMetaData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getFileMetaData, sizeof(struct tns__getFileMetaData), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getFileMetaData(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getFileMetaData *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getFileMetaData, sizeof(struct tns__getFileMetaData), 0), SOAP_TYPE_tns__getFileMetaData, sizeof(struct tns__getFileMetaData));
		if (soap->alloced)
			soap_default_tns__getFileMetaData(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__get(struct soap *soap, struct tns__get const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__get))
		soap_mark_tns__get(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__get(struct soap *soap, const struct tns__get *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__get(struct soap *soap, struct tns__get *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
	soap_default_PointerToArrayOfstring(soap, &a->arg1);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__get(struct soap *soap, struct tns__get *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__get, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__get(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__get(soap, tag, i, a, type);
		}
	else
		soap_out_tns__get(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__get(struct soap *soap, const char *tag, int id, const struct tns__get *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__get), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_out_PointerToArrayOfstring(soap, "arg1", -1, &a->arg1, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__get * SOAP_FMAC2 soap_get_tns__get(struct soap *soap, struct tns__get *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__get(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__get * SOAP_FMAC2 soap_in_tns__get(struct soap *soap, const char *tag, struct tns__get *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__get *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__get, sizeof(struct tns__get), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__get(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg1", &a->arg1, "xsd:string"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__get *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__get, sizeof(struct tns__get), 0), SOAP_TYPE_tns__get, sizeof(struct tns__get));
		if (soap->alloced)
			soap_default_tns__get(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__mkPermanent(struct soap *soap, struct tns__mkPermanent const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__mkPermanent))
		soap_mark_tns__mkPermanent(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__mkPermanent(struct soap *soap, const struct tns__mkPermanent *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__mkPermanent(struct soap *soap, struct tns__mkPermanent *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__mkPermanent(struct soap *soap, struct tns__mkPermanent *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__mkPermanent, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__mkPermanent(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__mkPermanent(soap, tag, i, a, type);
		}
	else
		soap_out_tns__mkPermanent(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__mkPermanent(struct soap *soap, const char *tag, int id, const struct tns__mkPermanent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__mkPermanent), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__mkPermanent * SOAP_FMAC2 soap_get_tns__mkPermanent(struct soap *soap, struct tns__mkPermanent *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__mkPermanent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__mkPermanent * SOAP_FMAC2 soap_in_tns__mkPermanent(struct soap *soap, const char *tag, struct tns__mkPermanent *a, const char *type)
{
	short soap_flag_arg0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__mkPermanent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__mkPermanent, sizeof(struct tns__mkPermanent), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__mkPermanent(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__mkPermanent *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__mkPermanent, sizeof(struct tns__mkPermanent), 0), SOAP_TYPE_tns__mkPermanent, sizeof(struct tns__mkPermanent));
		if (soap->alloced)
			soap_default_tns__mkPermanent(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__setFileStatus(struct soap *soap, struct tns__setFileStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__setFileStatus))
		soap_mark_tns__setFileStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__setFileStatus(struct soap *soap, const struct tns__setFileStatus *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_xsd__int);
	soap_embedded(soap, &a->arg2, SOAP_TYPE_xsd__string);
	soap_mark_xsd__string(soap, &a->arg2);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__setFileStatus(struct soap *soap, struct tns__setFileStatus *a)
{
	soap_default_xsd__int(soap, &a->arg0);
	soap_default_xsd__int(soap, &a->arg1);
	soap_default_xsd__string(soap, &a->arg2);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__setFileStatus(struct soap *soap, struct tns__setFileStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__setFileStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__setFileStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__setFileStatus(soap, tag, i, a, type);
		}
	else
		soap_out_tns__setFileStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__setFileStatus(struct soap *soap, const char *tag, int id, const struct tns__setFileStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__setFileStatus), type);
	soap_out_xsd__int(soap, "arg0", -1, &a->arg0, "xsd:int");
	soap_out_xsd__int(soap, "arg1", -1, &a->arg1, "xsd:int");
	soap_out_xsd__string(soap, "arg2", -1, &a->arg2, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__setFileStatus * SOAP_FMAC2 soap_get_tns__setFileStatus(struct soap *soap, struct tns__setFileStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__setFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__setFileStatus * SOAP_FMAC2 soap_in_tns__setFileStatus(struct soap *soap, const char *tag, struct tns__setFileStatus *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1, soap_flag_arg2 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__setFileStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setFileStatus, sizeof(struct tns__setFileStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__setFileStatus(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "arg0", &a->arg0, "xsd:int"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "arg1", &a->arg1, "xsd:int"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap_flag_arg2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__string(soap, "arg2", &a->arg2, "xsd:string"))
				{	soap_flag_arg2 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__setFileStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__setFileStatus, sizeof(struct tns__setFileStatus), 0), SOAP_TYPE_tns__setFileStatus, sizeof(struct tns__setFileStatus));
		if (soap->alloced)
			soap_default_tns__setFileStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__unPin(struct soap *soap, struct tns__unPin const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__unPin))
		soap_mark_tns__unPin(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__unPin(struct soap *soap, const struct tns__unPin *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__unPin(struct soap *soap, struct tns__unPin *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
	soap_default_xsd__int(soap, &a->arg1);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__unPin(struct soap *soap, struct tns__unPin *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__unPin, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__unPin(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__unPin(soap, tag, i, a, type);
		}
	else
		soap_out_tns__unPin(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__unPin(struct soap *soap, const char *tag, int id, const struct tns__unPin *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__unPin), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_out_xsd__int(soap, "arg1", -1, &a->arg1, "xsd:int");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__unPin * SOAP_FMAC2 soap_get_tns__unPin(struct soap *soap, struct tns__unPin *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__unPin(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__unPin * SOAP_FMAC2 soap_in_tns__unPin(struct soap *soap, const char *tag, struct tns__unPin *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__unPin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__unPin, sizeof(struct tns__unPin), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__unPin(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "arg1", &a->arg1, "xsd:int"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__unPin *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__unPin, sizeof(struct tns__unPin), 0), SOAP_TYPE_tns__unPin, sizeof(struct tns__unPin));
		if (soap->alloced)
			soap_default_tns__unPin(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__pin(struct soap *soap, struct tns__pin const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__pin))
		soap_mark_tns__pin(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__pin(struct soap *soap, const struct tns__pin *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__pin(struct soap *soap, struct tns__pin *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__pin(struct soap *soap, struct tns__pin *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__pin, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__pin(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__pin(soap, tag, i, a, type);
		}
	else
		soap_out_tns__pin(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__pin(struct soap *soap, const char *tag, int id, const struct tns__pin *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__pin), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__pin * SOAP_FMAC2 soap_get_tns__pin(struct soap *soap, struct tns__pin *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__pin(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__pin * SOAP_FMAC2 soap_in_tns__pin(struct soap *soap, const char *tag, struct tns__pin *a, const char *type)
{
	short soap_flag_arg0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__pin *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__pin, sizeof(struct tns__pin), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__pin(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__pin *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__pin, sizeof(struct tns__pin), 0), SOAP_TYPE_tns__pin, sizeof(struct tns__pin));
		if (soap->alloced)
			soap_default_tns__pin(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__advisoryDelete(struct soap *soap, struct tns__advisoryDelete const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__advisoryDelete))
		soap_mark_tns__advisoryDelete(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__advisoryDelete(struct soap *soap, const struct tns__advisoryDelete *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__advisoryDelete(struct soap *soap, struct tns__advisoryDelete *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__advisoryDelete(struct soap *soap, struct tns__advisoryDelete *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__advisoryDelete, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__advisoryDelete(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__advisoryDelete(soap, tag, i, a, type);
		}
	else
		soap_out_tns__advisoryDelete(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__advisoryDelete(struct soap *soap, const char *tag, int id, const struct tns__advisoryDelete *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__advisoryDelete), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__advisoryDelete * SOAP_FMAC2 soap_get_tns__advisoryDelete(struct soap *soap, struct tns__advisoryDelete *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__advisoryDelete(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__advisoryDelete * SOAP_FMAC2 soap_in_tns__advisoryDelete(struct soap *soap, const char *tag, struct tns__advisoryDelete *a, const char *type)
{
	short soap_flag_arg0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__advisoryDelete *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__advisoryDelete, sizeof(struct tns__advisoryDelete), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__advisoryDelete(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__advisoryDelete *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__advisoryDelete, sizeof(struct tns__advisoryDelete), 0), SOAP_TYPE_tns__advisoryDelete, sizeof(struct tns__advisoryDelete));
		if (soap->alloced)
			soap_default_tns__advisoryDelete(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__getEstGetTime(struct soap *soap, struct tns__getEstGetTime const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getEstGetTime))
		soap_mark_tns__getEstGetTime(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__getEstGetTime(struct soap *soap, const struct tns__getEstGetTime *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__getEstGetTime(struct soap *soap, struct tns__getEstGetTime *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
	soap_default_PointerToArrayOfstring(soap, &a->arg1);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__getEstGetTime(struct soap *soap, struct tns__getEstGetTime *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__getEstGetTime, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__getEstGetTime(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__getEstGetTime(soap, tag, i, a, type);
		}
	else
		soap_out_tns__getEstGetTime(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getEstGetTime(struct soap *soap, const char *tag, int id, const struct tns__getEstGetTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getEstGetTime), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_out_PointerToArrayOfstring(soap, "arg1", -1, &a->arg1, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__getEstGetTime * SOAP_FMAC2 soap_get_tns__getEstGetTime(struct soap *soap, struct tns__getEstGetTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getEstGetTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__getEstGetTime * SOAP_FMAC2 soap_in_tns__getEstGetTime(struct soap *soap, const char *tag, struct tns__getEstGetTime *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getEstGetTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstGetTime, sizeof(struct tns__getEstGetTime), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getEstGetTime(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg1", &a->arg1, "xsd:string"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getEstGetTime *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstGetTime, sizeof(struct tns__getEstGetTime), 0), SOAP_TYPE_tns__getEstGetTime, sizeof(struct tns__getEstGetTime));
		if (soap->alloced)
			soap_default_tns__getEstGetTime(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__getProtocols(struct soap *soap, struct tns__getProtocols const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getProtocols))
		soap_mark_tns__getProtocols(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__getProtocols(struct soap *soap, const struct tns__getProtocols *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__getProtocols(struct soap *soap, struct tns__getProtocols *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__getProtocols(struct soap *soap, struct tns__getProtocols *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__getProtocols, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__getProtocols(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__getProtocols(soap, tag, i, a, type);
		}
	else
		soap_out_tns__getProtocols(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getProtocols(struct soap *soap, const char *tag, int id, const struct tns__getProtocols *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getProtocols), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__getProtocols * SOAP_FMAC2 soap_get_tns__getProtocols(struct soap *soap, struct tns__getProtocols *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getProtocols(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__getProtocols * SOAP_FMAC2 soap_in_tns__getProtocols(struct soap *soap, const char *tag, struct tns__getProtocols *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getProtocols *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getProtocols, sizeof(struct tns__getProtocols), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getProtocols(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getProtocols *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getProtocols, sizeof(struct tns__getProtocols), 0), SOAP_TYPE_tns__getProtocols, sizeof(struct tns__getProtocols));
		if (soap->alloced)
			soap_default_tns__getProtocols(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__copy(struct soap *soap, struct tns__copy const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__copy))
		soap_mark_tns__copy(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__copy(struct soap *soap, const struct tns__copy *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg1);
	soap_embedded(soap, &a->arg2, SOAP_TYPE_PointerToArrayOfboolean);
	soap_mark_PointerToArrayOfboolean(soap, &a->arg2);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__copy(struct soap *soap, struct tns__copy *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
	soap_default_PointerToArrayOfstring(soap, &a->arg1);
	soap_default_PointerToArrayOfboolean(soap, &a->arg2);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__copy(struct soap *soap, struct tns__copy *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__copy, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__copy(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__copy(soap, tag, i, a, type);
		}
	else
		soap_out_tns__copy(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__copy(struct soap *soap, const char *tag, int id, const struct tns__copy *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__copy), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_out_PointerToArrayOfstring(soap, "arg1", -1, &a->arg1, "xsd:string");
	soap_out_PointerToArrayOfboolean(soap, "arg2", -1, &a->arg2, "xsd:boolean");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__copy * SOAP_FMAC2 soap_get_tns__copy(struct soap *soap, struct tns__copy *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__copy(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__copy * SOAP_FMAC2 soap_in_tns__copy(struct soap *soap, const char *tag, struct tns__copy *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1, soap_flag_arg2 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__copy *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__copy, sizeof(struct tns__copy), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__copy(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg1", &a->arg1, "xsd:string"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap_flag_arg2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfboolean(soap, "arg2", &a->arg2, "xsd:boolean"))
				{	soap_flag_arg2 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__copy *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__copy, sizeof(struct tns__copy), 0), SOAP_TYPE_tns__copy, sizeof(struct tns__copy));
		if (soap->alloced)
			soap_default_tns__copy(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__getRequestStatus(struct soap *soap, struct tns__getRequestStatus const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getRequestStatus))
		soap_mark_tns__getRequestStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__getRequestStatus(struct soap *soap, const struct tns__getRequestStatus *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_xsd__int);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__getRequestStatus(struct soap *soap, struct tns__getRequestStatus *a)
{
	soap_default_xsd__int(soap, &a->arg0);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__getRequestStatus(struct soap *soap, struct tns__getRequestStatus *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__getRequestStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__getRequestStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__getRequestStatus(soap, tag, i, a, type);
		}
	else
		soap_out_tns__getRequestStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getRequestStatus(struct soap *soap, const char *tag, int id, const struct tns__getRequestStatus *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getRequestStatus), type);
	soap_out_xsd__int(soap, "arg0", -1, &a->arg0, "xsd:int");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__getRequestStatus * SOAP_FMAC2 soap_get_tns__getRequestStatus(struct soap *soap, struct tns__getRequestStatus *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getRequestStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__getRequestStatus * SOAP_FMAC2 soap_in_tns__getRequestStatus(struct soap *soap, const char *tag, struct tns__getRequestStatus *a, const char *type)
{
	short soap_flag_arg0 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getRequestStatus *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getRequestStatus, sizeof(struct tns__getRequestStatus), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getRequestStatus(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_xsd__int(soap, "arg0", &a->arg0, "xsd:int"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getRequestStatus *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getRequestStatus, sizeof(struct tns__getRequestStatus), 0), SOAP_TYPE_tns__getRequestStatus, sizeof(struct tns__getRequestStatus));
		if (soap->alloced)
			soap_default_tns__getRequestStatus(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__put(struct soap *soap, struct tns__put const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__put))
		soap_mark_tns__put(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__put(struct soap *soap, const struct tns__put *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg1);
	soap_embedded(soap, &a->arg2, SOAP_TYPE_PointerToArrayOflong);
	soap_mark_PointerToArrayOflong(soap, &a->arg2);
	soap_embedded(soap, &a->arg3, SOAP_TYPE_PointerToArrayOfboolean);
	soap_mark_PointerToArrayOfboolean(soap, &a->arg3);
	soap_embedded(soap, &a->arg4, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg4);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__put(struct soap *soap, struct tns__put *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
	soap_default_PointerToArrayOfstring(soap, &a->arg1);
	soap_default_PointerToArrayOflong(soap, &a->arg2);
	soap_default_PointerToArrayOfboolean(soap, &a->arg3);
	soap_default_PointerToArrayOfstring(soap, &a->arg4);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__put(struct soap *soap, struct tns__put *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__put, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__put(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__put(soap, tag, i, a, type);
		}
	else
		soap_out_tns__put(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__put(struct soap *soap, const char *tag, int id, const struct tns__put *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__put), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_out_PointerToArrayOfstring(soap, "arg1", -1, &a->arg1, "xsd:string");
	soap_out_PointerToArrayOflong(soap, "arg2", -1, &a->arg2, "xsd:long");
	soap_out_PointerToArrayOfboolean(soap, "arg3", -1, &a->arg3, "xsd:boolean");
	soap_out_PointerToArrayOfstring(soap, "arg4", -1, &a->arg4, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__put * SOAP_FMAC2 soap_get_tns__put(struct soap *soap, struct tns__put *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__put(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__put * SOAP_FMAC2 soap_in_tns__put(struct soap *soap, const char *tag, struct tns__put *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1, soap_flag_arg2 = 1, soap_flag_arg3 = 1, soap_flag_arg4 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__put *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__put, sizeof(struct tns__put), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__put(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg1", &a->arg1, "xsd:string"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap_flag_arg2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOflong(soap, "arg2", &a->arg2, "xsd:long"))
				{	soap_flag_arg2 = 0;
					continue;
				}
			if (soap_flag_arg3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfboolean(soap, "arg3", &a->arg3, "xsd:boolean"))
				{	soap_flag_arg3 = 0;
					continue;
				}
			if (soap_flag_arg4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg4", &a->arg4, "xsd:string"))
				{	soap_flag_arg4 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__put *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__put, sizeof(struct tns__put), 0), SOAP_TYPE_tns__put, sizeof(struct tns__put));
		if (soap->alloced)
			soap_default_tns__put(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__getEstPutTime(struct soap *soap, struct tns__getEstPutTime const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__getEstPutTime))
		soap_mark_tns__getEstPutTime(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__getEstPutTime(struct soap *soap, const struct tns__getEstPutTime *a)
{
	soap_embedded(soap, &a->arg0, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg0);
	soap_embedded(soap, &a->arg1, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg1);
	soap_embedded(soap, &a->arg2, SOAP_TYPE_PointerToArrayOflong);
	soap_mark_PointerToArrayOflong(soap, &a->arg2);
	soap_embedded(soap, &a->arg3, SOAP_TYPE_PointerToArrayOfboolean);
	soap_mark_PointerToArrayOfboolean(soap, &a->arg3);
	soap_embedded(soap, &a->arg4, SOAP_TYPE_PointerToArrayOfstring);
	soap_mark_PointerToArrayOfstring(soap, &a->arg4);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__getEstPutTime(struct soap *soap, struct tns__getEstPutTime *a)
{
	soap_default_PointerToArrayOfstring(soap, &a->arg0);
	soap_default_PointerToArrayOfstring(soap, &a->arg1);
	soap_default_PointerToArrayOflong(soap, &a->arg2);
	soap_default_PointerToArrayOfboolean(soap, &a->arg3);
	soap_default_PointerToArrayOfstring(soap, &a->arg4);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__getEstPutTime(struct soap *soap, struct tns__getEstPutTime *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__getEstPutTime, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__getEstPutTime(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__getEstPutTime(soap, tag, i, a, type);
		}
	else
		soap_out_tns__getEstPutTime(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__getEstPutTime(struct soap *soap, const char *tag, int id, const struct tns__getEstPutTime *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__getEstPutTime), type);
	soap_out_PointerToArrayOfstring(soap, "arg0", -1, &a->arg0, "xsd:string");
	soap_out_PointerToArrayOfstring(soap, "arg1", -1, &a->arg1, "xsd:string");
	soap_out_PointerToArrayOflong(soap, "arg2", -1, &a->arg2, "xsd:long");
	soap_out_PointerToArrayOfboolean(soap, "arg3", -1, &a->arg3, "xsd:boolean");
	soap_out_PointerToArrayOfstring(soap, "arg4", -1, &a->arg4, "xsd:string");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__getEstPutTime * SOAP_FMAC2 soap_get_tns__getEstPutTime(struct soap *soap, struct tns__getEstPutTime *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__getEstPutTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__getEstPutTime * SOAP_FMAC2 soap_in_tns__getEstPutTime(struct soap *soap, const char *tag, struct tns__getEstPutTime *a, const char *type)
{
	short soap_flag_arg0 = 1, soap_flag_arg1 = 1, soap_flag_arg2 = 1, soap_flag_arg3 = 1, soap_flag_arg4 = 1;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__getEstPutTime *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstPutTime, sizeof(struct tns__getEstPutTime), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__getEstPutTime(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_arg0 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg0", &a->arg0, "xsd:string"))
				{	soap_flag_arg0 = 0;
					continue;
				}
			if (soap_flag_arg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg1", &a->arg1, "xsd:string"))
				{	soap_flag_arg1 = 0;
					continue;
				}
			if (soap_flag_arg2 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOflong(soap, "arg2", &a->arg2, "xsd:long"))
				{	soap_flag_arg2 = 0;
					continue;
				}
			if (soap_flag_arg3 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfboolean(soap, "arg3", &a->arg3, "xsd:boolean"))
				{	soap_flag_arg3 = 0;
					continue;
				}
			if (soap_flag_arg4 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfstring(soap, "arg4", &a->arg4, "xsd:string"))
				{	soap_flag_arg4 = 0;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__getEstPutTime *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__getEstPutTime, sizeof(struct tns__getEstPutTime), 0), SOAP_TYPE_tns__getEstPutTime, sizeof(struct tns__getEstPutTime));
		if (soap->alloced)
			soap_default_tns__getEstPutTime(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_tns__ping(struct soap *soap, struct tns__ping const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_tns__ping))
		soap_mark_tns__ping(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_tns__ping(struct soap *soap, const struct tns__ping *a)
{
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_tns__ping(struct soap *soap, struct tns__ping *a)
{
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_tns__ping(struct soap *soap, struct tns__ping *a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_tns__ping, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_tns__ping(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_tns__ping(soap, tag, i, a, type);
		}
	else
		soap_out_tns__ping(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_tns__ping(struct soap *soap, const char *tag, int id, const struct tns__ping *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_tns__ping), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC1 struct tns__ping * SOAP_FMAC2 soap_get_tns__ping(struct soap *soap, struct tns__ping *p, const char *tag, const char *type)
{
	if ((p = soap_in_tns__ping(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct tns__ping * SOAP_FMAC2 soap_in_tns__ping(struct soap *soap, const char *tag, struct tns__ping *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (*soap->type && soap_match_tag(soap, soap->type, type))
	{	soap->error = SOAP_TYPE_MISMATCH;
		soap_revert(soap);
		return NULL;
	}
	if (soap->null)
	{	if (soap->mode & SOAP_XML_NIL)
		{	soap->error = SOAP_NULL;
			return NULL;
		}
		else
			return a;
	}
	if (!*soap->href)
	{	a = (struct tns__ping *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__ping, sizeof(struct tns__ping), 0);
		if (!a)
			return NULL;
		if (soap->alloced)
			soap_default_tns__ping(soap, a);
		if (soap->body)
		{	for (;;)
			{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
			{	return NULL;
			}
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
		}
	}
	else
	{	a = (struct tns__ping *)soap_id_forward(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_tns__ping, sizeof(struct tns__ping), 0), SOAP_TYPE_tns__ping, sizeof(struct tns__ping));
		if (soap->alloced)
			soap_default_tns__ping(soap, a);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code))
		soap_mark_PointerToSOAP_ENV__Code(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_mark_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToSOAP_ENV__Code, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToSOAP_ENV__Code(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToSOAP_ENV__Code(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_SOAP_ENV__Code(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_SOAP_ENV__Code(soap, tag, i, *a, type);
			}
		else
			soap_out_SOAP_ENV__Code(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_SOAP_ENV__Code, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 struct SOAP_ENV__Code ** SOAP_FMAC2 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	struct SOAP_ENV__Code *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_SOAP_ENV__Code(soap, tag, NULL, type)))
		{	a = (struct SOAP_ENV__Code **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToSOAP_ENV__Code, sizeof(struct SOAP_ENV__Code *), 1), SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__getFileMetaDataResponse(struct soap *soap, tns__getFileMetaDataResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getFileMetaDataResponse))
		soap_mark_PointerTotns__getFileMetaDataResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__getFileMetaDataResponse(struct soap *soap, tns__getFileMetaDataResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getFileMetaDataResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__getFileMetaDataResponse(struct soap *soap, tns__getFileMetaDataResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__getFileMetaDataResponse(struct soap *soap, tns__getFileMetaDataResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__getFileMetaDataResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__getFileMetaDataResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__getFileMetaDataResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__getFileMetaDataResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__getFileMetaDataResponse(struct soap *soap, const char *tag, int id, tns__getFileMetaDataResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getFileMetaDataResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getFileMetaDataResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getFileMetaDataResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__getFileMetaDataResponse ** SOAP_FMAC2 soap_get_PointerTotns__getFileMetaDataResponse(struct soap *soap, tns__getFileMetaDataResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getFileMetaDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__getFileMetaDataResponse ** SOAP_FMAC2 soap_in_PointerTotns__getFileMetaDataResponse(struct soap *soap, const char *tag, tns__getFileMetaDataResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getFileMetaDataResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getFileMetaDataResponse, sizeof(tns__getFileMetaDataResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getFileMetaDataResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getFileMetaDataResponse, sizeof(tns__getFileMetaDataResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getFileMetaDataResponse *)soap_instantiate_tns__getFileMetaDataResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getFileMetaDataResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getFileMetaDataResponse, sizeof(tns__getFileMetaDataResponse *), 1), SOAP_TYPE_tns__getFileMetaDataResponse, sizeof(tns__getFileMetaDataResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__getResponse(struct soap *soap, tns__getResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getResponse))
		soap_mark_PointerTotns__getResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__getResponse(struct soap *soap, tns__getResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__getResponse(struct soap *soap, tns__getResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__getResponse(struct soap *soap, tns__getResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__getResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__getResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__getResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__getResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__getResponse(struct soap *soap, const char *tag, int id, tns__getResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__getResponse ** SOAP_FMAC2 soap_get_PointerTotns__getResponse(struct soap *soap, tns__getResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__getResponse ** SOAP_FMAC2 soap_in_PointerTotns__getResponse(struct soap *soap, const char *tag, tns__getResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getResponse, sizeof(tns__getResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getResponse, sizeof(tns__getResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getResponse *)soap_instantiate_tns__getResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getResponse, sizeof(tns__getResponse *), 1), SOAP_TYPE_tns__getResponse, sizeof(tns__getResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__mkPermanentResponse(struct soap *soap, tns__mkPermanentResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__mkPermanentResponse))
		soap_mark_PointerTotns__mkPermanentResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__mkPermanentResponse(struct soap *soap, tns__mkPermanentResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__mkPermanentResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__mkPermanentResponse(struct soap *soap, tns__mkPermanentResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__mkPermanentResponse(struct soap *soap, tns__mkPermanentResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__mkPermanentResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__mkPermanentResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__mkPermanentResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__mkPermanentResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__mkPermanentResponse(struct soap *soap, const char *tag, int id, tns__mkPermanentResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__mkPermanentResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__mkPermanentResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__mkPermanentResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__mkPermanentResponse ** SOAP_FMAC2 soap_get_PointerTotns__mkPermanentResponse(struct soap *soap, tns__mkPermanentResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__mkPermanentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__mkPermanentResponse ** SOAP_FMAC2 soap_in_PointerTotns__mkPermanentResponse(struct soap *soap, const char *tag, tns__mkPermanentResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__mkPermanentResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__mkPermanentResponse, sizeof(tns__mkPermanentResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__mkPermanentResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__mkPermanentResponse, sizeof(tns__mkPermanentResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__mkPermanentResponse *)soap_instantiate_tns__mkPermanentResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__mkPermanentResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__mkPermanentResponse, sizeof(tns__mkPermanentResponse *), 1), SOAP_TYPE_tns__mkPermanentResponse, sizeof(tns__mkPermanentResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__setFileStatusResponse(struct soap *soap, tns__setFileStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__setFileStatusResponse))
		soap_mark_PointerTotns__setFileStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__setFileStatusResponse(struct soap *soap, tns__setFileStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__setFileStatusResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__setFileStatusResponse(struct soap *soap, tns__setFileStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__setFileStatusResponse(struct soap *soap, tns__setFileStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__setFileStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__setFileStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__setFileStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__setFileStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__setFileStatusResponse(struct soap *soap, const char *tag, int id, tns__setFileStatusResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__setFileStatusResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__setFileStatusResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__setFileStatusResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__setFileStatusResponse ** SOAP_FMAC2 soap_get_PointerTotns__setFileStatusResponse(struct soap *soap, tns__setFileStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__setFileStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__setFileStatusResponse ** SOAP_FMAC2 soap_in_PointerTotns__setFileStatusResponse(struct soap *soap, const char *tag, tns__setFileStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__setFileStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__setFileStatusResponse, sizeof(tns__setFileStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__setFileStatusResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__setFileStatusResponse, sizeof(tns__setFileStatusResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__setFileStatusResponse *)soap_instantiate_tns__setFileStatusResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__setFileStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__setFileStatusResponse, sizeof(tns__setFileStatusResponse *), 1), SOAP_TYPE_tns__setFileStatusResponse, sizeof(tns__setFileStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__unPinResponse(struct soap *soap, tns__unPinResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__unPinResponse))
		soap_mark_PointerTotns__unPinResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__unPinResponse(struct soap *soap, tns__unPinResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__unPinResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__unPinResponse(struct soap *soap, tns__unPinResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__unPinResponse(struct soap *soap, tns__unPinResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__unPinResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__unPinResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__unPinResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__unPinResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__unPinResponse(struct soap *soap, const char *tag, int id, tns__unPinResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__unPinResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__unPinResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__unPinResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__unPinResponse ** SOAP_FMAC2 soap_get_PointerTotns__unPinResponse(struct soap *soap, tns__unPinResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__unPinResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__unPinResponse ** SOAP_FMAC2 soap_in_PointerTotns__unPinResponse(struct soap *soap, const char *tag, tns__unPinResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__unPinResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__unPinResponse, sizeof(tns__unPinResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__unPinResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__unPinResponse, sizeof(tns__unPinResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__unPinResponse *)soap_instantiate_tns__unPinResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__unPinResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__unPinResponse, sizeof(tns__unPinResponse *), 1), SOAP_TYPE_tns__unPinResponse, sizeof(tns__unPinResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__pinResponse(struct soap *soap, tns__pinResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__pinResponse))
		soap_mark_PointerTotns__pinResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__pinResponse(struct soap *soap, tns__pinResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__pinResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__pinResponse(struct soap *soap, tns__pinResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__pinResponse(struct soap *soap, tns__pinResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__pinResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__pinResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__pinResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__pinResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__pinResponse(struct soap *soap, const char *tag, int id, tns__pinResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__pinResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__pinResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__pinResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__pinResponse ** SOAP_FMAC2 soap_get_PointerTotns__pinResponse(struct soap *soap, tns__pinResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__pinResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__pinResponse ** SOAP_FMAC2 soap_in_PointerTotns__pinResponse(struct soap *soap, const char *tag, tns__pinResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__pinResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__pinResponse, sizeof(tns__pinResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__pinResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__pinResponse, sizeof(tns__pinResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__pinResponse *)soap_instantiate_tns__pinResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__pinResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__pinResponse, sizeof(tns__pinResponse *), 1), SOAP_TYPE_tns__pinResponse, sizeof(tns__pinResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__advisoryDeleteResponse(struct soap *soap, tns__advisoryDeleteResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__advisoryDeleteResponse))
		soap_mark_PointerTotns__advisoryDeleteResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__advisoryDeleteResponse(struct soap *soap, tns__advisoryDeleteResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__advisoryDeleteResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__advisoryDeleteResponse(struct soap *soap, tns__advisoryDeleteResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__advisoryDeleteResponse(struct soap *soap, tns__advisoryDeleteResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__advisoryDeleteResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__advisoryDeleteResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__advisoryDeleteResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__advisoryDeleteResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__advisoryDeleteResponse(struct soap *soap, const char *tag, int id, tns__advisoryDeleteResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__advisoryDeleteResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__advisoryDeleteResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__advisoryDeleteResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__advisoryDeleteResponse ** SOAP_FMAC2 soap_get_PointerTotns__advisoryDeleteResponse(struct soap *soap, tns__advisoryDeleteResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__advisoryDeleteResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__advisoryDeleteResponse ** SOAP_FMAC2 soap_in_PointerTotns__advisoryDeleteResponse(struct soap *soap, const char *tag, tns__advisoryDeleteResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__advisoryDeleteResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__advisoryDeleteResponse, sizeof(tns__advisoryDeleteResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__advisoryDeleteResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__advisoryDeleteResponse, sizeof(tns__advisoryDeleteResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__advisoryDeleteResponse *)soap_instantiate_tns__advisoryDeleteResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__advisoryDeleteResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__advisoryDeleteResponse, sizeof(tns__advisoryDeleteResponse *), 1), SOAP_TYPE_tns__advisoryDeleteResponse, sizeof(tns__advisoryDeleteResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__getEstGetTimeResponse(struct soap *soap, tns__getEstGetTimeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getEstGetTimeResponse))
		soap_mark_PointerTotns__getEstGetTimeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__getEstGetTimeResponse(struct soap *soap, tns__getEstGetTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getEstGetTimeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__getEstGetTimeResponse(struct soap *soap, tns__getEstGetTimeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__getEstGetTimeResponse(struct soap *soap, tns__getEstGetTimeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__getEstGetTimeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__getEstGetTimeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__getEstGetTimeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__getEstGetTimeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__getEstGetTimeResponse(struct soap *soap, const char *tag, int id, tns__getEstGetTimeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getEstGetTimeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getEstGetTimeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getEstGetTimeResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__getEstGetTimeResponse ** SOAP_FMAC2 soap_get_PointerTotns__getEstGetTimeResponse(struct soap *soap, tns__getEstGetTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getEstGetTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__getEstGetTimeResponse ** SOAP_FMAC2 soap_in_PointerTotns__getEstGetTimeResponse(struct soap *soap, const char *tag, tns__getEstGetTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getEstGetTimeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getEstGetTimeResponse, sizeof(tns__getEstGetTimeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getEstGetTimeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getEstGetTimeResponse, sizeof(tns__getEstGetTimeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getEstGetTimeResponse *)soap_instantiate_tns__getEstGetTimeResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getEstGetTimeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getEstGetTimeResponse, sizeof(tns__getEstGetTimeResponse *), 1), SOAP_TYPE_tns__getEstGetTimeResponse, sizeof(tns__getEstGetTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__getProtocolsResponse(struct soap *soap, tns__getProtocolsResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getProtocolsResponse))
		soap_mark_PointerTotns__getProtocolsResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__getProtocolsResponse(struct soap *soap, tns__getProtocolsResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getProtocolsResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__getProtocolsResponse(struct soap *soap, tns__getProtocolsResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__getProtocolsResponse(struct soap *soap, tns__getProtocolsResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__getProtocolsResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__getProtocolsResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__getProtocolsResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__getProtocolsResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__getProtocolsResponse(struct soap *soap, const char *tag, int id, tns__getProtocolsResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getProtocolsResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getProtocolsResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getProtocolsResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__getProtocolsResponse ** SOAP_FMAC2 soap_get_PointerTotns__getProtocolsResponse(struct soap *soap, tns__getProtocolsResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getProtocolsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__getProtocolsResponse ** SOAP_FMAC2 soap_in_PointerTotns__getProtocolsResponse(struct soap *soap, const char *tag, tns__getProtocolsResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getProtocolsResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getProtocolsResponse, sizeof(tns__getProtocolsResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getProtocolsResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getProtocolsResponse, sizeof(tns__getProtocolsResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getProtocolsResponse *)soap_instantiate_tns__getProtocolsResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getProtocolsResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getProtocolsResponse, sizeof(tns__getProtocolsResponse *), 1), SOAP_TYPE_tns__getProtocolsResponse, sizeof(tns__getProtocolsResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__copyResponse(struct soap *soap, tns__copyResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__copyResponse))
		soap_mark_PointerTotns__copyResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__copyResponse(struct soap *soap, tns__copyResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__copyResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__copyResponse(struct soap *soap, tns__copyResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__copyResponse(struct soap *soap, tns__copyResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__copyResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__copyResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__copyResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__copyResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__copyResponse(struct soap *soap, const char *tag, int id, tns__copyResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__copyResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__copyResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__copyResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__copyResponse ** SOAP_FMAC2 soap_get_PointerTotns__copyResponse(struct soap *soap, tns__copyResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__copyResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__copyResponse ** SOAP_FMAC2 soap_in_PointerTotns__copyResponse(struct soap *soap, const char *tag, tns__copyResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__copyResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__copyResponse, sizeof(tns__copyResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__copyResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__copyResponse, sizeof(tns__copyResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__copyResponse *)soap_instantiate_tns__copyResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__copyResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__copyResponse, sizeof(tns__copyResponse *), 1), SOAP_TYPE_tns__copyResponse, sizeof(tns__copyResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__getRequestStatusResponse(struct soap *soap, tns__getRequestStatusResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getRequestStatusResponse))
		soap_mark_PointerTotns__getRequestStatusResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__getRequestStatusResponse(struct soap *soap, tns__getRequestStatusResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getRequestStatusResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__getRequestStatusResponse(struct soap *soap, tns__getRequestStatusResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__getRequestStatusResponse(struct soap *soap, tns__getRequestStatusResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__getRequestStatusResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__getRequestStatusResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__getRequestStatusResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__getRequestStatusResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__getRequestStatusResponse(struct soap *soap, const char *tag, int id, tns__getRequestStatusResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getRequestStatusResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getRequestStatusResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getRequestStatusResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__getRequestStatusResponse ** SOAP_FMAC2 soap_get_PointerTotns__getRequestStatusResponse(struct soap *soap, tns__getRequestStatusResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getRequestStatusResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__getRequestStatusResponse ** SOAP_FMAC2 soap_in_PointerTotns__getRequestStatusResponse(struct soap *soap, const char *tag, tns__getRequestStatusResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getRequestStatusResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getRequestStatusResponse, sizeof(tns__getRequestStatusResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getRequestStatusResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getRequestStatusResponse, sizeof(tns__getRequestStatusResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getRequestStatusResponse *)soap_instantiate_tns__getRequestStatusResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getRequestStatusResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getRequestStatusResponse, sizeof(tns__getRequestStatusResponse *), 1), SOAP_TYPE_tns__getRequestStatusResponse, sizeof(tns__getRequestStatusResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__putResponse(struct soap *soap, tns__putResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__putResponse))
		soap_mark_PointerTotns__putResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__putResponse(struct soap *soap, tns__putResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__putResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__putResponse(struct soap *soap, tns__putResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__putResponse(struct soap *soap, tns__putResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__putResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__putResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__putResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__putResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__putResponse(struct soap *soap, const char *tag, int id, tns__putResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__putResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__putResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__putResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__putResponse ** SOAP_FMAC2 soap_get_PointerTotns__putResponse(struct soap *soap, tns__putResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__putResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__putResponse ** SOAP_FMAC2 soap_in_PointerTotns__putResponse(struct soap *soap, const char *tag, tns__putResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__putResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__putResponse, sizeof(tns__putResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__putResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__putResponse, sizeof(tns__putResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__putResponse *)soap_instantiate_tns__putResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__putResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__putResponse, sizeof(tns__putResponse *), 1), SOAP_TYPE_tns__putResponse, sizeof(tns__putResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__getEstPutTimeResponse(struct soap *soap, tns__getEstPutTimeResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__getEstPutTimeResponse))
		soap_mark_PointerTotns__getEstPutTimeResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__getEstPutTimeResponse(struct soap *soap, tns__getEstPutTimeResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__getEstPutTimeResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__getEstPutTimeResponse(struct soap *soap, tns__getEstPutTimeResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__getEstPutTimeResponse(struct soap *soap, tns__getEstPutTimeResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__getEstPutTimeResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__getEstPutTimeResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__getEstPutTimeResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__getEstPutTimeResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__getEstPutTimeResponse(struct soap *soap, const char *tag, int id, tns__getEstPutTimeResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__getEstPutTimeResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__getEstPutTimeResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__getEstPutTimeResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__getEstPutTimeResponse ** SOAP_FMAC2 soap_get_PointerTotns__getEstPutTimeResponse(struct soap *soap, tns__getEstPutTimeResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__getEstPutTimeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__getEstPutTimeResponse ** SOAP_FMAC2 soap_in_PointerTotns__getEstPutTimeResponse(struct soap *soap, const char *tag, tns__getEstPutTimeResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__getEstPutTimeResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getEstPutTimeResponse, sizeof(tns__getEstPutTimeResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__getEstPutTimeResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__getEstPutTimeResponse, sizeof(tns__getEstPutTimeResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__getEstPutTimeResponse *)soap_instantiate_tns__getEstPutTimeResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__getEstPutTimeResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__getEstPutTimeResponse, sizeof(tns__getEstPutTimeResponse *), 1), SOAP_TYPE_tns__getEstPutTimeResponse, sizeof(tns__getEstPutTimeResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToArrayOfboolean(struct soap *soap, ArrayOfboolean *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOfboolean))
		soap_mark_PointerToArrayOfboolean(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToArrayOfboolean(struct soap *soap, ArrayOfboolean *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfboolean))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToArrayOfboolean(struct soap *soap, ArrayOfboolean **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToArrayOfboolean(struct soap *soap, ArrayOfboolean **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToArrayOfboolean, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToArrayOfboolean(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToArrayOfboolean(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToArrayOfboolean(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToArrayOfboolean(struct soap *soap, const char *tag, int id, ArrayOfboolean *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOfboolean);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfboolean, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOfboolean, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ArrayOfboolean ** SOAP_FMAC2 soap_get_PointerToArrayOfboolean(struct soap *soap, ArrayOfboolean **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfboolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ArrayOfboolean ** SOAP_FMAC2 soap_in_PointerToArrayOfboolean(struct soap *soap, const char *tag, ArrayOfboolean **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOfboolean **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfboolean, sizeof(ArrayOfboolean *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOfboolean **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOfboolean, sizeof(ArrayOfboolean *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOfboolean *)soap_instantiate_ArrayOfboolean(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOfboolean **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfboolean, sizeof(ArrayOfboolean *), 1), SOAP_TYPE_ArrayOfboolean, sizeof(ArrayOfboolean), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToArrayOflong(struct soap *soap, ArrayOflong *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOflong))
		soap_mark_PointerToArrayOflong(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToArrayOflong(struct soap *soap, ArrayOflong *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOflong))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToArrayOflong(struct soap *soap, ArrayOflong **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToArrayOflong(struct soap *soap, ArrayOflong **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToArrayOflong, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToArrayOflong(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToArrayOflong(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToArrayOflong(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToArrayOflong(struct soap *soap, const char *tag, int id, ArrayOflong *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOflong);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOflong, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOflong, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ArrayOflong ** SOAP_FMAC2 soap_get_PointerToArrayOflong(struct soap *soap, ArrayOflong **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOflong(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ArrayOflong ** SOAP_FMAC2 soap_in_PointerToArrayOflong(struct soap *soap, const char *tag, ArrayOflong **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOflong **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOflong, sizeof(ArrayOflong *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOflong **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOflong, sizeof(ArrayOflong *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOflong *)soap_instantiate_ArrayOflong(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOflong **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOflong, sizeof(ArrayOflong *), 1), SOAP_TYPE_ArrayOflong, sizeof(ArrayOflong), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTotns__pingResponse(struct soap *soap, tns__pingResponse *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTotns__pingResponse))
		soap_mark_PointerTotns__pingResponse(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTotns__pingResponse(struct soap *soap, tns__pingResponse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_tns__pingResponse))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTotns__pingResponse(struct soap *soap, tns__pingResponse **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTotns__pingResponse(struct soap *soap, tns__pingResponse **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTotns__pingResponse, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTotns__pingResponse(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTotns__pingResponse(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTotns__pingResponse(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTotns__pingResponse(struct soap *soap, const char *tag, int id, tns__pingResponse *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTotns__pingResponse);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_tns__pingResponse, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_tns__pingResponse, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 tns__pingResponse ** SOAP_FMAC2 soap_get_PointerTotns__pingResponse(struct soap *soap, tns__pingResponse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTotns__pingResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 tns__pingResponse ** SOAP_FMAC2 soap_in_PointerTotns__pingResponse(struct soap *soap, const char *tag, tns__pingResponse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (tns__pingResponse **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__pingResponse, sizeof(tns__pingResponse *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (tns__pingResponse **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTotns__pingResponse, sizeof(tns__pingResponse *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (tns__pingResponse *)soap_instantiate_tns__pingResponse(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (tns__pingResponse **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTotns__pingResponse, sizeof(tns__pingResponse *), 1), SOAP_TYPE_tns__pingResponse, sizeof(tns__pingResponse), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToxsd__boolean(struct soap *soap, bool *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToxsd__boolean))
		soap_mark_PointerToxsd__boolean(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToxsd__boolean(struct soap *soap, bool *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__boolean);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToxsd__boolean(struct soap *soap, bool **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToxsd__boolean(struct soap *soap, bool **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToxsd__boolean, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToxsd__boolean(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToxsd__boolean(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToxsd__boolean(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToxsd__boolean(struct soap *soap, const char *tag, int id, bool *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToxsd__boolean);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_xsd__boolean, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_xsd__boolean(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_xsd__boolean(soap, tag, i, *a, type);
			}
		else
			soap_out_xsd__boolean(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_xsd__boolean, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 bool ** SOAP_FMAC2 soap_get_PointerToxsd__boolean(struct soap *soap, bool **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__boolean(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 bool ** SOAP_FMAC2 soap_in_PointerToxsd__boolean(struct soap *soap, const char *tag, bool **a, const char *type)
{
	bool *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (bool **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__boolean, sizeof(bool *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_xsd__boolean(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_xsd__boolean(soap, tag, NULL, type)))
		{	a = (bool **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToxsd__boolean, sizeof(bool *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (bool **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__boolean, sizeof(bool *), 1), SOAP_TYPE_xsd__boolean, sizeof(bool), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToArrayOfstring(struct soap *soap, ArrayOfstring *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOfstring))
		soap_mark_PointerToArrayOfstring(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToArrayOfstring(struct soap *soap, ArrayOfstring *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfstring))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToArrayOfstring(struct soap *soap, ArrayOfstring **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToArrayOfstring(struct soap *soap, ArrayOfstring **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToArrayOfstring, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToArrayOfstring(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToArrayOfstring(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToArrayOfstring(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToArrayOfstring(struct soap *soap, const char *tag, int id, ArrayOfstring *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOfstring);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfstring, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOfstring, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ArrayOfstring ** SOAP_FMAC2 soap_get_PointerToArrayOfstring(struct soap *soap, ArrayOfstring **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfstring(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ArrayOfstring ** SOAP_FMAC2 soap_in_PointerToArrayOfstring(struct soap *soap, const char *tag, ArrayOfstring **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOfstring **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfstring, sizeof(ArrayOfstring *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOfstring **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOfstring, sizeof(ArrayOfstring *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOfstring *)soap_instantiate_ArrayOfstring(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOfstring **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfstring, sizeof(ArrayOfstring *), 1), SOAP_TYPE_ArrayOfstring, sizeof(ArrayOfstring), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToArrayOfFileMetaData(struct soap *soap, ArrayOfFileMetaData *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOfFileMetaData))
		soap_mark_PointerToArrayOfFileMetaData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToArrayOfFileMetaData(struct soap *soap, ArrayOfFileMetaData *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfFileMetaData))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToArrayOfFileMetaData(struct soap *soap, ArrayOfFileMetaData **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToArrayOfFileMetaData(struct soap *soap, ArrayOfFileMetaData **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToArrayOfFileMetaData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToArrayOfFileMetaData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToArrayOfFileMetaData(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToArrayOfFileMetaData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToArrayOfFileMetaData(struct soap *soap, const char *tag, int id, ArrayOfFileMetaData *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOfFileMetaData);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfFileMetaData, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOfFileMetaData, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ArrayOfFileMetaData ** SOAP_FMAC2 soap_get_PointerToArrayOfFileMetaData(struct soap *soap, ArrayOfFileMetaData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfFileMetaData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ArrayOfFileMetaData ** SOAP_FMAC2 soap_in_PointerToArrayOfFileMetaData(struct soap *soap, const char *tag, ArrayOfFileMetaData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOfFileMetaData **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfFileMetaData, sizeof(ArrayOfFileMetaData *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOfFileMetaData **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOfFileMetaData, sizeof(ArrayOfFileMetaData *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOfFileMetaData *)soap_instantiate_ArrayOfFileMetaData(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOfFileMetaData **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfFileMetaData, sizeof(ArrayOfFileMetaData *), 1), SOAP_TYPE_ArrayOfFileMetaData, sizeof(ArrayOfFileMetaData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTons11__RequestFileStatus(struct soap *soap, ns11__RequestFileStatus *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons11__RequestFileStatus))
		soap_mark_PointerTons11__RequestFileStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTons11__RequestFileStatus(struct soap *soap, ns11__RequestFileStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns11__RequestFileStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTons11__RequestFileStatus(struct soap *soap, ns11__RequestFileStatus **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTons11__RequestFileStatus(struct soap *soap, ns11__RequestFileStatus **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTons11__RequestFileStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTons11__RequestFileStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTons11__RequestFileStatus(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTons11__RequestFileStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTons11__RequestFileStatus(struct soap *soap, const char *tag, int id, ns11__RequestFileStatus *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons11__RequestFileStatus);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns11__RequestFileStatus, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns11__RequestFileStatus, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ns11__RequestFileStatus ** SOAP_FMAC2 soap_get_PointerTons11__RequestFileStatus(struct soap *soap, ns11__RequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons11__RequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ns11__RequestFileStatus ** SOAP_FMAC2 soap_in_PointerTons11__RequestFileStatus(struct soap *soap, const char *tag, ns11__RequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns11__RequestFileStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons11__RequestFileStatus, sizeof(ns11__RequestFileStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns11__RequestFileStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons11__RequestFileStatus, sizeof(ns11__RequestFileStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns11__RequestFileStatus *)soap_instantiate_ns11__RequestFileStatus(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns11__RequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons11__RequestFileStatus, sizeof(ns11__RequestFileStatus *), 1), SOAP_TYPE_ns11__RequestFileStatus, sizeof(ns11__RequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToxsd__long(struct soap *soap, LONG64 *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToxsd__long))
		soap_mark_PointerToxsd__long(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToxsd__long(struct soap *soap, LONG64 *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__long);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToxsd__long(struct soap *soap, LONG64 **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToxsd__long(struct soap *soap, LONG64 **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToxsd__long, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToxsd__long(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToxsd__long(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToxsd__long(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToxsd__long(struct soap *soap, const char *tag, int id, LONG64 *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToxsd__long);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_xsd__long, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_xsd__long(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_xsd__long(soap, tag, i, *a, type);
			}
		else
			soap_out_xsd__long(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_xsd__long, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 LONG64 ** SOAP_FMAC2 soap_get_PointerToxsd__long(struct soap *soap, LONG64 **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__long(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 LONG64 ** SOAP_FMAC2 soap_in_PointerToxsd__long(struct soap *soap, const char *tag, LONG64 **a, const char *type)
{
	LONG64 *p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (LONG64 **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__long, sizeof(LONG64 *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_xsd__long(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_xsd__long(soap, tag, NULL, type)))
		{	a = (LONG64 **)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToxsd__long, sizeof(LONG64 *), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (LONG64 **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__long, sizeof(LONG64 *), 1), SOAP_TYPE_xsd__long, sizeof(LONG64), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToxsd__string))
		soap_mark_PointerToxsd__string(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToxsd__string(struct soap *soap, char **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__string))
		soap_mark_xsd__string(soap, *a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToxsd__string(struct soap *soap, char ***a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToxsd__string(struct soap *soap, char ***a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToxsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToxsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToxsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToxsd__string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToxsd__string(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToxsd__string);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_xsd__string, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				soap_out_xsd__string(soap, tag, 0, *a, type);
			else
			{	soap_set_embedded(soap, pp);
				soap_out_xsd__string(soap, tag, i, *a, type);
			}
		else
			soap_out_xsd__string(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_xsd__string, &pp), *a, type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 char *** SOAP_FMAC2 soap_get_PointerToxsd__string(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char *** SOAP_FMAC2 soap_in_PointerToxsd__string(struct soap *soap, const char *tag, char ***a, const char *type)
{
	char **p;
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (char ***)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__string, sizeof(char **), 2);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		if (a)
		{	if ((p = soap_in_xsd__string(soap, tag, *a, type)))
				*a = p;
			else
				a = NULL;
		}
		else if ((p = soap_in_xsd__string(soap, tag, NULL, type)))
		{	a = (char ***)soap_id_enter(soap, "", NULL, SOAP_TYPE_PointerToxsd__string, sizeof(char **), 0);
			if (a)
				*a = p;
		}
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToxsd__string, sizeof(char **), 2), SOAP_TYPE_xsd__string, sizeof(char *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTons11__FileMetaData(struct soap *soap, ns11__FileMetaData *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons11__FileMetaData))
		soap_mark_PointerTons11__FileMetaData(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTons11__FileMetaData(struct soap *soap, ns11__FileMetaData *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns11__FileMetaData))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTons11__FileMetaData(struct soap *soap, ns11__FileMetaData **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTons11__FileMetaData(struct soap *soap, ns11__FileMetaData **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTons11__FileMetaData, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTons11__FileMetaData(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTons11__FileMetaData(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTons11__FileMetaData(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTons11__FileMetaData(struct soap *soap, const char *tag, int id, ns11__FileMetaData *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons11__FileMetaData);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns11__FileMetaData, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns11__FileMetaData, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ns11__FileMetaData ** SOAP_FMAC2 soap_get_PointerTons11__FileMetaData(struct soap *soap, ns11__FileMetaData **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons11__FileMetaData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ns11__FileMetaData ** SOAP_FMAC2 soap_in_PointerTons11__FileMetaData(struct soap *soap, const char *tag, ns11__FileMetaData **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns11__FileMetaData **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons11__FileMetaData, sizeof(ns11__FileMetaData *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns11__FileMetaData **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons11__FileMetaData, sizeof(ns11__FileMetaData *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns11__FileMetaData *)soap_instantiate_ns11__FileMetaData(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns11__FileMetaData **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons11__FileMetaData, sizeof(ns11__FileMetaData *), 1), SOAP_TYPE_ns11__FileMetaData, sizeof(ns11__FileMetaData), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerToArrayOfRequestFileStatus(struct soap *soap, ArrayOfRequestFileStatus *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerToArrayOfRequestFileStatus))
		soap_mark_PointerToArrayOfRequestFileStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerToArrayOfRequestFileStatus(struct soap *soap, ArrayOfRequestFileStatus *const*a)
{
	if (*a && !soap_array_reference(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfRequestFileStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerToArrayOfRequestFileStatus(struct soap *soap, ArrayOfRequestFileStatus **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerToArrayOfRequestFileStatus(struct soap *soap, ArrayOfRequestFileStatus **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerToArrayOfRequestFileStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerToArrayOfRequestFileStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerToArrayOfRequestFileStatus(soap, tag, i, a, type);
		}
	else
		soap_out_PointerToArrayOfRequestFileStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerToArrayOfRequestFileStatus(struct soap *soap, const char *tag, int id, ArrayOfRequestFileStatus *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerToArrayOfRequestFileStatus);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_array_pointer_lookup(soap, *a, (struct soap_array*)&(*a)->__ptr, (*a)->__size, SOAP_TYPE_ArrayOfRequestFileStatus, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ArrayOfRequestFileStatus, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ArrayOfRequestFileStatus ** SOAP_FMAC2 soap_get_PointerToArrayOfRequestFileStatus(struct soap *soap, ArrayOfRequestFileStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfRequestFileStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ArrayOfRequestFileStatus ** SOAP_FMAC2 soap_in_PointerToArrayOfRequestFileStatus(struct soap *soap, const char *tag, ArrayOfRequestFileStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ArrayOfRequestFileStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfRequestFileStatus, sizeof(ArrayOfRequestFileStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ArrayOfRequestFileStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerToArrayOfRequestFileStatus, sizeof(ArrayOfRequestFileStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ArrayOfRequestFileStatus *)soap_instantiate_ArrayOfRequestFileStatus(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ArrayOfRequestFileStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerToArrayOfRequestFileStatus, sizeof(ArrayOfRequestFileStatus *), 1), SOAP_TYPE_ArrayOfRequestFileStatus, sizeof(ArrayOfRequestFileStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_PointerTons11__RequestStatus(struct soap *soap, ns11__RequestStatus *const*a)
{
	if (!soap_reference(soap, a, SOAP_TYPE_PointerTons11__RequestStatus))
		soap_mark_PointerTons11__RequestStatus(soap, a);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_PointerTons11__RequestStatus(struct soap *soap, ns11__RequestStatus *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns11__RequestStatus))
		(*a)->soap_mark(soap);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_PointerTons11__RequestStatus(struct soap *soap, ns11__RequestStatus **a)
{
	*a = NULL;
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_PointerTons11__RequestStatus(struct soap *soap, ns11__RequestStatus **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_PointerTons11__RequestStatus, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_PointerTons11__RequestStatus(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_PointerTons11__RequestStatus(soap, tag, i, a, type);
		}
	else
		soap_out_PointerTons11__RequestStatus(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_PointerTons11__RequestStatus(struct soap *soap, const char *tag, int id, ns11__RequestStatus *const*a, const char *type)
{
	id = soap_embedded_id(soap, id, a, SOAP_TYPE_PointerTons11__RequestStatus);
	if (!*a)
		soap_element_null(soap, tag, id, type);
	else
	{	struct soap_plist *pp;
		int i = soap_pointer_lookup(soap, *a, SOAP_TYPE_ns11__RequestStatus, &pp);
		if (i)
			if (soap_is_embedded(soap, pp))
				soap_element_ref(soap, tag, id, i);
			else if (soap_is_single(soap, pp))
				(*a)->soap_out(soap, tag, 0, type);
			else
			{	soap_set_embedded(soap, pp);
				(*a)->soap_out(soap, tag, i, type);
			}
		else
			(*a)->soap_out(soap, tag, soap_pointer_enter(soap, *a, SOAP_TYPE_ns11__RequestStatus, &pp), type);
	}
	return SOAP_OK;
}

SOAP_FMAC1 ns11__RequestStatus ** SOAP_FMAC2 soap_get_PointerTons11__RequestStatus(struct soap *soap, ns11__RequestStatus **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons11__RequestStatus(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 ns11__RequestStatus ** SOAP_FMAC2 soap_in_PointerTons11__RequestStatus(struct soap *soap, const char *tag, ns11__RequestStatus **a, const char *type)
{
	if (soap_element_begin_in(soap, tag))
		return NULL;
	if (soap->null)
	{	a = (ns11__RequestStatus **)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons11__RequestStatus, sizeof(ns11__RequestStatus *), 1);
		if (a)
			*a = NULL;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	else if (!*soap->href)
	{	soap_revert(soap);
		a = (ns11__RequestStatus **)soap_id_enter(soap, "", a, SOAP_TYPE_PointerTons11__RequestStatus, sizeof(ns11__RequestStatus *), 0);
		if (a)
		{	if (soap->alloced || !*a)
				*a = (ns11__RequestStatus *)soap_instantiate_ns11__RequestStatus(soap, -1, soap->type, soap->arrayType);
			if (!*a)
				a = NULL;
			else
			{	(*a)->soap_default(soap);
				if (!(*a)->soap_in(soap, tag, NULL))
					a = NULL;
			}
		}
	}
	else
	{	a = (ns11__RequestStatus **)soap_id_lookup(soap, soap->href, (void**)soap_id_enter(soap, soap->id, a, SOAP_TYPE_PointerTons11__RequestStatus, sizeof(ns11__RequestStatus *), 1), SOAP_TYPE_ns11__RequestStatus, sizeof(ns11__RequestStatus), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__dateTime(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__dateTime
	*a = SOAP_DEFAULT_xsd__dateTime;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__dateTime(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__dateTime(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__dateTime(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__dateTime, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__dateTime(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__dateTime(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__dateTime(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__dateTime(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__dateTime);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__dateTime(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__dateTime(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__dateTime(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__dateTime, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_xsd__string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_xsd__string
	*a = SOAP_DEFAULT_xsd__string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_xsd__string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_xsd__string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_xsd__string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_xsd__string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_xsd__string(soap, tag, i, a, type);
		}
	else
		soap_out_xsd__string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_xsd__string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_xsd__string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_xsd__string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_xsd__string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_xsd__string, 1);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_default_string(struct soap *soap, char **a)
{
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC1 void SOAP_FMAC2 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC1 void SOAP_FMAC2 soap_mark_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_put_string(struct soap *soap, char **a, const char *tag, const char *type)
{
	int i;
	struct soap_plist *pp;
	if ((i = soap_pointer_lookup(soap, a, SOAP_TYPE_string, &pp)))
		if (soap_is_embedded(soap, pp))
			soap_element_ref(soap, tag, 0, i);
		else if (soap_is_single(soap, pp))
			soap_out_string(soap, tag, 0, a, type);
		else
		{
			soap_set_embedded(soap, pp);
			soap_out_string(soap, tag, i, a, type);
		}
	else
		soap_out_string(soap, tag, 0, a, type);
	return soap_putindependent(soap);
}

SOAP_FMAC1 int SOAP_FMAC2 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC1 char ** SOAP_FMAC2 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 char * * SOAP_FMAC2 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1);
}

/* end of soapC.cpp */
