#  -----------------------------------------------------------------------
#     dCache default values
#  -----------------------------------------------------------------------
@DEFAULTS_HEADER@

#  -----------------------------------------------------------------------
#     Parameters related to CDMI startup
#  -----------------------------------------------------------------------
cdmi.cell.name=cdmi

(one-of?true|false|${dcache.enable.space-reservation})cdmi.enable.space-reservation=${dcache.enable.space-reservation}

#  The port cdmi will listen on.
cdmi.net.port=8543
#
#  The interface cdmi will listen on.
cdmi.net.listen=${dcache.net.listen}

# ---- Host name of cdmi service
#
# For certain operations cdmi needs to know its domain name.  The
# property "cdmiHost" can be used to override the default value.  If
# this value is not set, the value is detected automatically and it is
# equivalent to the output of the unix hostname program.
#
cdmi.net.host=${host.fqdn}

# ---- Maximum number of threads used for cdmi request processing
#
# Whenever a client submits an cdmi request a thread is allocated. This
# setting controls the maximum number of such threads.
#
# Notice that this does not control the number of cdmi transfers that
# can be active at any given time: An cdmi transfer involves several
# requests by the client (eg cdmiPrepareToGet, cdmiStatusOfGetRequest,
# cdmiReleaseFiles).
#
# There is also a choice whether to process requests synchronously or
# asynchronously. If processed synchronously, the request is not
# answered until processed. This means that a thread is bound to the
# request for the duration of the request processing. If prcessed
# asynchronous, the thread is released right away and the client
# submits new requests to poll for the completion of the previously
# submitted request. This adds latency and increases authentication
# overhead, but frees thread and TCP connections.
#
cdmi.limits.threads.max = 500

# ---- Minimum number of threads used for cdmi request processing
cdmi.limits.threads.min = 10

# ---- Threads that accept TCP connections
#
# The number of threads that accept and dispatch new client connections.
# Except under very high connection rates, a single thread should be
# sufficient.
#
cdmi.limits.acceptors=1


# ---- TCP backlog
#
# Maximum number of TCP connections queued for accept. If the acceptor
# threads cannot keep up, up to this number of connections are queued
# before new connections are rejected.
cdmi.limits.backlog=1024


# ---- Time before an idle connection is closed
cdmi.limits.idle-time = 30
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.limits.idle-time.unit = SECONDS

# ---- Time before an idle requst-processing thread is terminated
cdmi.limits.threads.idle-time = 60
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.limits.threads.idle-time.unit = SECONDS

# ---- Maximum number of queued cdmi requests
#
# Once the limit is reached no new connections will be accepted;
# instead, the operating system will queue them in the TCP backlog.
# Once the TCP backlog is filled, the operating system will reject
# further TCP connections.
#
cdmi.limits.queue-length = 500

# set graceful shutdown timeout. If set, the internal doStop() method
# will not immediately stop the server. Instead, all Connectors will
# be closed so that new connections will not be accepted and all handlers that
# implement Server.Graceful will be put into the shutdown mode so that no
# new requests will be accepted, but existing requests can complete.
# The server will then wait the configured timeout before stopping.
cdmi.limits.jetty.graceful-shutdown=2000
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)cdmi.limits.jetty.graceful-shutdown.unit = MILLISECONDS

cdmi.service.pnfsmanager = ${dcache.service.pnfsmanager}
cdmi.service.pnfsmanager.timeout = 2
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.service.pnfsmanager.timeout.unit = MINUTES

cdmi.service.billing = ${dcache.service.billing}

cdmi.service.pool.timeout = 10
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.service.pool.timeout.unit = SECONDS

cdmi.service.gplazma=${dcache.service.gplazma}
cdmi.service.gplazma.timeout = 3
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.service.gplazma.timeout.unit = MINUTES

cdmi.service.poolmanager=${cdmi.service.poolmanager-space-${cdmi.enable.space-reservation}}
cdmi.service.poolmanager.timeout=5
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.service.poolmanager.timeout.unit = MINUTES

(immutable)cdmi.service.poolmanager-space-false=${dcache.service.poolmanager}
(immutable)cdmi.service.poolmanager-space-true=${dcache.service.spacemanager}
(one-of?true|false|${dcache.enable.spacemanager})\
    cdmi.enable.spacemanager=${dcache.enable.spacemanager}


# ---- Shutdown timeout
#
# During shutdown no new connections will be accepted. Existing
# connections will be given this much time to complete the
# request, after which the connections are forcefully broken.
#
cdmi.limits.graceful-shutdown=2
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.limits.graceful-shutdown.unit=SECONDS


# ---- Time before an idle TCP connection is closed during high load
#
# An idle connection is one on which no data is transferred. The door
# is considered under high load when all request processing threads
# are busy.
#
# Under high load, new connections will be configured with this timeout
# rather than the timeout defined by cdmi.limits.idle-time. Currently,
# existing connections are not affected, although this may change in
# the future.
#
cdmi.limits.low-resource-idle-time=30
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS)\
    cdmi.limits.low-resource-idle-time.unit=SECONDS


#  Flags to disable problematic crypto ciphers
#
#  See dcache.authn.ciphers for details.
cdmi.authn.ciphers = ${dcache.authn.ciphers}


#  ---- Whether client certificates are accepted
#
#   This parameter specifies whether the CDMI door will accept a
#   client certificate for authentication.
#
(one-of?true|false)cdmi.authn.accept-client-cert = true


#  ---- Whether client certificates are required
#
#   This parameter specifies whether the CDMI door will require a
#   client certificate for authentication.
#
(one-of?true|false)cdmi.authn.require-client-cert = false

# Path to directory with trusted CA certificates for https authentication
cdmi.authn.capath=${dcache.authn.capath}

# How often to check the CA certificates for updates
cdmi.authn.capath.refresh=${dcache.authn.capath.refresh}
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS|${dcache.authn.capath.refresh.unit})\
    cdmi.authn.capath.refresh.unit=${dcache.authn.capath.refresh.unit}

# Host (server) certificate
cdmi.authn.hostcert.cert=${dcache.authn.hostcert.cert}

# Host (server) key
cdmi.authn.hostcert.key=${dcache.authn.hostcert.key}

# How often to check the host certificate for updates
cdmi.authn.hostcert.refresh=${dcache.authn.hostcert.refresh}
(one-of?MILLISECONDS|SECONDS|MINUTES|HOURS|DAYS|${dcache.authn.hostcert.refresh.unit})\
    cdmi.authn.hostcert.refresh.unit=${dcache.authn.hostcert.refresh.unit}

#  Whether any operations are allowed for anonymous users.
(one-of?true|false)cdmi.authz.anonymous-operations=false

#
#   Document which TCP ports are opened
#
(immutable)cdmi.net.ports.tcp=${cdmi.net.port}

